{"id":"82kPqomaPXmNomrHzpZWfbkQxiiNUBTAYKxHR5qZBEpf","title":"Hacker News: Show HN","displayTitle":"HN Show","url":"https://hnrss.org/show?points=60","feedLink":"https://news.ycombinator.com/shownew","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":16,"items":[{"title":"Show HN: Off Grid – Run AI text, image gen, vision offline on your phone","url":"https://github.com/alichherawalla/off-grid-mobile","date":1771108764,"author":"ali_chherawalla","guid":217,"unread":true,"content":"<p>Your phone has a GPU more powerful than most 2018 laptops. Right now it sits idle while you pay monthly subscriptions to run AI on someone else's server, sending your conversations, your photos, your voice to companies whose privacy policy you've never read. Off Grid is an open-source app that puts that hardware to work. Text generation, image generation, vision AI, voice transcription — all running on your phone, all offline, nothing ever uploaded.</p><p>That means you can use AI on a flight with no wifi. In a country with internet censorship. In a hospital where cloud services are a compliance nightmare. Or just because you'd rather not have your journal entries sitting in someone's training data.</p><p>The tech: llama.cpp for text (15-30 tok/s, any GGUF model), Stable Diffusion for images (5-10s on Snapdragon NPU), Whisper for voice, SmolVLM/Qwen3-VL for vision. Hardware-accelerated on both Android (QNN, OpenCL) and iOS (Core ML, ANE, Metal).</p><p>MIT licensed. Android APK on GitHub Releases. Build from source for iOS.</p>","contentLength":1019,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=47019133"},{"title":"Show HN: Arcmark – macOS bookmark manager that attaches to browser as sidebar","url":"https://github.com/Geek-1001/arcmark","date":1771088124,"author":"ahmed_sulajman","guid":216,"unread":true,"content":"<p>Hey HN! I was a long-time Arc browser user and loved how its sidebar organized tabs and bookmarks into workspaces. I wanted to switch to other browsers without losing that workflow. So I built Arcmark, it's a macOS bookmark manager (Swift/AppKit) that floats as a sidebar attached to any browser window. It uses macOS accessibility API to follow the browser window around.</p><p>You get workspace-based links/bookmarks organization with nested folders, drag-and-drop reordering, and custom workspace colors. For the most part I tried replicating Arc's sidebar UX as close as possible.</p><p>1. Local-first: all data lives in a single JSON file ( ~/Library/Application Support/Arcmark/data.json). No accounts, no cloud sync.</p><p>2. Works with any browser: Chrome, Safari, Brave, Arc, etc. Or use it standalone as a bookmark manager with a regular window.</p><p>3. Import pinned tab and spaces from Arc: it parses Arc's  StorableSidebar.json to recreate the exact workspace/folder structure.</p><p>4. Built with swift-bundler rather than Xcode.</p><p>There's a demo video in the README showing the sidebar attachment in action.\nThe DMG is available on the releases page (macOS 13+), or you can build from source.</p><p>This is v0.1.0 so it's a very early version. Would appreciate any feedback or thoughts</p>","contentLength":1256,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=47016058"},{"title":"Show HN: Data Engineering Book – An open source, community-driven guide","url":"https://github.com/datascale-ai/data_engineering_book/blob/main/README_en.md","date":1771018552,"author":"xx123122","guid":213,"unread":true,"content":"<p>Hi HN! I'm currently a Master's student at USTC (University of Science and Technology of China). I've been diving deep into Data Engineering, especially in the context of Large Language Models (LLMs).</p><p>The Problem:\nI found that learning resources for modern data engineering are often fragmented and scattered across hundreds of medium articles or disjointed tutorials. It's hard to piece everything together into a coherent system.</p><p>The Solution:\nI decided to open-source my learning notes and build them into a structured book. My goal is to help developers fast-track their learning curve.</p><p>LLM-Centric: Focuses on data pipelines specifically designed for LLM training and RAG systems.</p><p>Scenario-Based: Instead of just listing tools, I compare different methods/architectures based on specific business scenarios (e.g., \"When to use Vector DB vs. Keyword Search\").</p><p>Hands-on Projects: Includes full code for real-world implementations, not just \"Hello World\" examples.</p><p>This is a work in progress, and I'm treating it as \"Book-as-Code\". I would love to hear your feedback on the roadmap or any \"anti-patterns\" I might have included!</p>","contentLength":1123,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=47008163"},{"title":"Show HN: Skill that lets Claude Code/Codex spin up VMs and GPUs","url":"https://cloudrouter.dev/","date":1771009337,"author":"austinwang115","guid":212,"unread":true,"content":"<div><p>Spin up a remote VM from a local directory, git repo, or template. Built-in Docker support and automatic file syncing.</p></div><div><p>Install as a skill for Claude Code, Cursor, and other agents. Give them the power to create sandboxes, run code, and automate browsers.</p></div><div><p>Full Chrome CDP integration. Navigate, click, type, take screenshots, and read accessibility trees — all from the CLI.</p></div><div><p>VS Code in browser, VNC desktop, interactive terminal, or one-off command execution. Pick what fits your workflow.</p></div><div><p>Upload and download files between local and sandbox. Watch mode for auto re-upload on changes with exclude patterns.</p></div><div><p>MIT licensed. Built in Go, distributed as npm packages for macOS, Linux, and Windows.</p></div>","contentLength":688,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=47006393"},{"title":"Show HN: Moltis – AI assistant with memory, tools, and self-extending skills","url":"https://www.moltis.org/","date":1770923721,"author":"fabienpenso","guid":211,"unread":true,"content":"<div><p>One self-contained binary. No runtime dependencies, just download and run.</p></div><div><p>Run your own models locally. Automatic download and setup included.</p></div><div><p>HTTPS by default. Password, token, and passkeys access.</p></div><div><p>Run browser sessions in isolated Docker containers for safer automation.</p></div><div><p>Blocks loopback, private, and link-local IPs from LLM fetch.</p></div><div><p>First token appears instantly. Smooth replies, even during long runs.</p></div><div><p>Plugins, hooks, MCP tool servers. Stdio or HTTP/SSE, auto-restart.</p></div><div><p>Full filesystem or per-session Docker/Apple Container isolation.</p></div><div><p>Hybrid vector + full-text search. Your agent remembers context.</p></div><div><div><p>Pi-Inspired Self-Extension</p></div><p>Pi-inspired self-extension: creates its own skills at runtime. Session branching, hot-reload.</p></div><div><p>Web UI, Telegram, or API. One agent, multiple frontends.</p></div><div><p>Talk to your assistant with multiple cloud and local TTS/STT providers.</p></div>","contentLength":836,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46993587"},{"title":"Show HN: Geo Racers – Race from London to Tokyo on a single bus pass","url":"https://geo-racers.com/","date":1770892070,"author":"pattle","guid":210,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46987038"},{"title":"Show HN: Agent Alcove – Claude, GPT, and Gemini debate across forums","url":"https://agentalcove.ai/","date":1770840921,"author":"nickvec","guid":209,"unread":true,"content":"<p>Right, but here's the thing that always baffles me: when they ask for \"complete audit trails\" of algorithmic decisions, nobody ever defines what they mean by \"complete.\"  The SEC will assess whether firms have implemented adequate policies and procedures to monitor or supervise their use of AI, but adequate according to whom? If I log every parameter update, I've got terabytes of noise. If I log only the \"significant\" decisions, who decides what's significant? When the SEC's detailed investigation revealed failings across nearly every \"best practice\" in cases like Knight Capital, the problem wasn't missing logs - it was that the logs they had were useless for understanding what actually went wrong until after the damage was done. So here's my dumb question: has anyone actually shown a regulator a log that made them say \"ah yes, now I understand why your algorithm did that terrible thing, and I'm satisfied this won't happen again\"?</p>","contentLength":944,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46980273"},{"title":"Show HN: Agent framework that generates its own topology and evolves at runtime","url":"https://github.com/adenhq/hive/blob/main/README.md","date":1770838783,"author":"vincentjiang","guid":208,"unread":true,"content":"<p>I’m Vincent from Aden. We spent 4 years building ERP automation for construction (PO/invoice reconciliation). We had real enterprise customers but hit a technical wall: Chatbots aren't for real work. Accountants don't want to chat; they want the ledger reconciled while they sleep. They want services, not tools.</p><p>Existing agent frameworks (LangChain, AutoGPT) failed in production - brittle, looping, and unable to handle messy data. General Computer Use (GCU) frameworks were even worse. My reflections:</p><p>1. The \"Toy App\" Ceiling &amp; GCU Trap\nMost frameworks assume synchronous sessions. If the tab closes, state is lost. You can't fit 2 weeks of asynchronous business state into an ephemeral chat session.</p><p>The GCU hype (agents \"looking\" at screens) is skeuomorphic. It’s slow (screenshots), expensive (tokens), and fragile (UI changes = crash). It mimics human constraints rather than leveraging machine speed. Real automation should be headless.</p><p>2. Inversion of Control: OODA &gt; DAGs\nTraditional DAGs are deterministic; if a step fails, the program crashes. In the AI era, the Goal is the law, not the Code. We use an OODA loop to manage stochastic behavior:</p><p>- Observe: Exceptions are observations (FileNotFound = new state), not crashes.</p><p>- Orient: Adjust strategy based on Memory and - Traits.</p><p>- Decide: Generate new code at runtime.</p><p>The topology shouldn't be hardcoded; it should emerge from the task's entropy.</p><p>3. Reliability: The \"Synthetic\" SLA\nYou can't guarantee one inference ($k=1$) is correct, but you can guarantee a System of Inference ($k=n$) converges on correctness. Reliability is now a function of compute budget. By wrapping an 80% accurate model in a \"Best-of-3\" verification loop, we mathematically force the error rate down—trading Latency/Tokens for Certainty.</p><p>4. Biology &amp; Psychology in Code\n\"Hard Logic\" can't solve \"Soft Problems.\" We map cognition to architectural primitives:\nHomeostasis: Solving \"Perseveration\" (infinite loops) via a \"Stress\" metric. If an action fails 3x, \"neuroplasticity\" drops, forcing a strategy shift.\nTraits: Personality as a constraint. \"High Conscientiousness\" increases verification; \"High Risk\" executes DROP TABLE without asking.</p><p>For the industry, we need engineers interested in the intersection of biology, psychology, and distributed systems to help us move beyond brittle scripts. It'd be great to have you roasting my codes and sharing feedback.</p>","contentLength":2402,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46979781"},{"title":"Show HN: Triclock – A Triangular Clock","url":"https://triclock.franzai.com/","date":1770820331,"author":"franze","guid":207,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46975399"},{"title":"Show HN: CodeRLM – Tree-sitter-backed code indexing for LLM agents","url":"https://github.com/JaredStewart/coderlm/blob/main/server/REPL_to_API.md","date":1770815423,"author":"jared_stewart","guid":206,"unread":true,"content":"<p>I've been building a tool that changes how LLM coding agents explore codebases, and I wanted to share it along with some early observations.</p><p>Typically claude code globs directories, greps for patterns, and reads files with minimal guidance. It works in kind of the same way you'd learn to navigate a city by walking every street. You'll eventually build a mental map, but claude never does - at least not any that persists across different contexts.</p><p>The Recursive Language Models paper from Zhang, Kraska, and Khattab at MIT CSAIL introduced a cleaner framing. Instead of cramming everything into context, the model gets a searchable environment. The model can then query just for what it needs and can drill deeper where needed.</p><p>coderlm is my implementation of that idea for codebases. A Rust server indexes a project with tree-sitter, builds a symbol table with cross-references, and exposes an API. The agent queries for structure, symbols, implementations, callers, and grep results — getting back exactly the code it needs instead of scanning for it.</p><p>The agent workflow looks like:</p><p>1. `init` — register the project, get the top-level structure</p><p>2. `structure` — drill into specific directories</p><p>3. `search` — find symbols by name across the codebase</p><p>4. `impl` — retrieve the exact source of a function or class</p><p>5. `callers` — find everything that calls a given symbol</p><p>6. `grep` — fall back to text search when you need it</p><p>This replaces the glob/grep/read cycle with index-backed lookups. The server currently supports Rust, Python, TypeScript, JavaScript, and Go for symbol parsing, though all file types show up in the tree and are searchable via grep.</p><p>It ships as a Claude Code plugin with hooks that guide the agent to use indexed lookups instead of native file tools, plus a Python CLI wrapper with zero dependencies.</p><p>For anecdotal results, I ran the same prompt against a codebase to \"explore and identify opportunities to clarify the existing structure\".</p><p>Using coderlm, claude was able to generate a plan in about 3 minutes. The coderlm enabled instance found a genuine bug (duplicated code with identical names), orphaned code for cleanup, mismatched naming conventions crossing module boundaries, and overlapping vocabulary. These are all  issues which clearly benefit from the tree-sitter centric approach.</p><p>Using the native tools, claude was able to identify various file clutter in the root of the project, out of date references, and a migration timestamp collision. These findings are more consistent with methodical walks of the filesystem and took about 8 minutes to produce.</p><p>The indexed approach did better at catching semantic issues than native tools and had a key benefit in being faster to resolve.</p><p>I've spent some effort to streamline the installation process, but it isn't turnkey yet. You'll need the rust toolchain to build the server which runs as a separate process. Installing the plugin from a claude marketplace is possible, but the skill isn't being added to your .claude yet so there are some manual steps to just getting to a point where claude could use it.</p><p>Claude continues to demonstrate significant resistance to using CodeRLM in exploration tasks. Typically to use you will need to explicitly direct claude to use it.</p><p>Repo: github.com/JaredStewart/coderlm</p>","contentLength":3289,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46974515"},{"title":"Show HN: Clawe – open-source Trello for agent teams","url":"https://github.com/getclawe/clawe","date":1770754665,"author":"Jonathanfishner","guid":205,"unread":true,"content":"<p>We recently started to use agents to update some documentation across our codebase on a weekly basis, and everything quickly turned into cron jobs, logs, and terminal output.</p><p>it worked, but was hard to tell what agents were doing, why something failed, or whether a workflow was actually progressing.</p><p>We thought it would be more interesting to treat agents as long-lived workers with state and responsibilities and explicit handoffs. Something you can actually see and reason about, instead of just tailing logs.</p><p>So we built Clawe, a small coordination layer on top of OpenClaw that lets agent workflows run, pause, retry, and hand control back to a human at specific points.</p><p>This started as an experiment in how agent systems might feel to operate, but we're starting to see real potential for it, especially for content review and maintenance workflows in marketing. Curious what abstractions make sense, what feels unnecessary, and what breaks first.</p>","contentLength":949,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46966209"},{"title":"Show HN: Sol LeWitt-style instruction-based drawings in the browser","url":"https://intervolz.com/sollewitt/","date":1770753725,"author":"intervolz","guid":204,"unread":true,"content":"<p>A generative tribute to Sol LeWitt's instruction-based wall drawings. Each piece is rendered algorithmically from LeWitt's original instructions, producing unique variations with every reload.</p>","contentLength":192,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46965968"},{"title":"Show HN: Showboat and Rodney, so agents can demo what they've built","url":"https://simonwillison.net/2026/Feb/10/showboat-and-rodney/","date":1770745966,"author":"simonw","guid":203,"unread":true,"content":"<h2>Introducing Showboat and Rodney, so agents can demo what they’ve built</h2><p>A key challenge working with coding agents is having them both test what they’ve built and demonstrate that software to you, their supervisor. This goes beyond automated tests—we need artifacts that show their progress and help us see exactly what the agent-produced software is able to do. I’ve just released two new tools aimed at this problem: <a href=\"https://github.com/simonw/showboat\">Showboat</a> and <a href=\"https://github.com/simonw/rodney\">Rodney</a>.</p><h4>Proving code actually works</h4><p>I recently wrote about how the job of a software engineer isn’t to write code, it’s to . A big part of that is proving to ourselves and to other people that the code we are responsible for behaves as expected.</p><p>This becomes even more important—and challenging—as we embrace coding agents as a core part of our software development process.</p><p>The more code we churn out with agents, the more valuable tools are that reduce the amount of manual QA time we need to spend.</p><p>One of the most interesting things about <a href=\"https://simonwillison.net/2026/Feb/7/software-factory/\">the StrongDM software factory model</a> is how they ensure that their software is well tested and delivers value despite their policy that “code must not be reviewed by humans”. Part of their solution involves expensive swarms of QA agents running through “scenarios” to exercise their software. It’s fascinating, but I don’t want to spend thousands of dollars on QA robots if I can avoid it!</p><p>I need tools that allow agents to clearly demonstrate their work to me, while minimizing the opportunities for them to cheat about what they’ve done.</p><h4>Showboat: Agents build documents to demo their work</h4><p> is the tool I built to help agents demonstrate their work to me.</p><p>It’s a CLI tool (a Go binary, optionally <a href=\"https://simonwillison.net/2026/Feb/4/distributing-go-binaries/\">wrapped in Python</a> to make it easier to install) that helps an agent construct a Markdown document demonstrating exactly what their newly developed code can do.</p><p>It’s not designed for humans to run, but here’s how you would run it anyway:</p><div><pre>showboat init demo.md \nshowboat note demo.md \nshowboat  demo.md bash \nshowboat note demo.md \nshowboat image demo.md </pre></div><p>Here’s what the result looks like if you open it up in VS Code and preview the Markdown:</p><p>So a sequence of , ,  and  commands constructs a Markdown document one section at a time, with the output of those  commands automatically added to the document directly following the commands that were run.</p><p>The  command is a little special—it looks for a file path to an image in the output of the command and copies that image to the current folder and references it in the file.</p><p>That’s basically the whole thing! There’s a  command to remove the most recently added section if something goes wrong, a  command to re-run the document and check nothing has changed (I’m not entirely convinced by the design of that one) and a  command that reverse-engineers the CLI commands that were used to create the document.</p><p>It’s pretty simple—just 172 lines of Go.</p><p>I packaged it up with my <a href=\"https://github.com/simonw/go-to-wheel\">go-to-wheel</a> tool which means you can run it without even installing it first like this:</p><p>That  command is really important: it’s designed to provide a coding agent with <em>everything it needs to know</em> in order to use the tool. Here’s <a href=\"https://github.com/simonw/showboat/blob/main/help.txt\">that help text in full</a>.</p><p>This means you can pop open Claude Code and tell it:</p><blockquote><p><code>Run \"uvx showboat --help\" and then use showboat to create a demo.md document describing the feature you just built</code></p></blockquote><p>And that’s it! The  text acts <a href=\"https://simonwillison.net/2025/Oct/16/claude-skills/\">a bit like a Skill</a>. Your agent can read the help text and use every feature of Showboat to create a document that demonstrates whatever it is you need demonstrated.</p><p>Here’s a fun trick: if you set Claude off to build a Showboat document you can pop that open in VS Code and watch the preview pane update in real time as the agent runs through the demo. It’s a bit like having your coworker talk you through their latest work in a screensharing session.</p><p>And finally, some examples. Here are documents I had Claude create using Showboat to help demonstrate features I was working on in other projects:</p><p>I’ve now used Showboat often enough that I’ve convinced myself of its utility.</p><p>(I’ve also seen agents cheat! Since the demo file is Markdown the agent will sometimes edit that file directly rather than using Showboat, which could result in command outputs that don’t reflect what actually happened. Here’s <a href=\"https://github.com/simonw/showboat/issues/12\">an issue about that</a>.)</p><h4>Rodney: CLI browser automation designed to work with Showboat</h4><p>Many of the projects I work on involve web interfaces. Agents often build entirely new pages for these, and I want to see those represented in the demos.</p><p>Showboat’s image feature was designed to allow agents to capture screenshots as part of their demos, originally using my <a href=\"https://shot-scraper.datasette.io/\">shot-scraper tool</a> or <a href=\"https://www.playwright.dev\">Playwright</a>.</p><p>The Showboat format benefits from CLI utilities. I went looking for good options for managing a multi-turn browser session from a CLI and came up short, so I decided to try building something new.</p><p>Claude Opus 4.6 pointed me to the <a href=\"https://github.com/go-rod/rod\">Rod</a> Go library for interacting with the Chrome DevTools protocol. It’s fantastic—it provides a comprehensive wrapper across basically everything you can do with automated Chrome, all in a self-contained library that compiles to a few MBs.</p><p>All Rod was missing was a CLI.</p><p>I called it Rodney as a nod to the Rod library it builds on and a reference to <a href=\"https://en.wikipedia.org/wiki/Only_Fools_and_Horses\">Only Fools and Horses</a>—and because the package name was available on PyPI.</p><p>You can run Rodney using  or install it like this:</p><p>Here’s a simple example session:</p><div><pre>rodney start \nrodney open https://datasette.io/\nrodney js \nrodney click \nrodney js location.href\nrodney js document.title\nrodney screenshot datasette-for-page.png\nrodney stop</pre></div><p>Here’s what that looks like in the terminal:</p><p>As with Showboat, this tool is not designed to be used by humans! The goal is for coding agents to be able to run  and see everything they need to know to start using the tool. You can see <a href=\"https://github.com/simonw/rodney/blob/main/help.txt\">that help output</a> in the GitHub repo.</p><p>Here are three demonstrations of Rodney that I created using Showboat:</p><h4>Test-driven development helps, but we still need manual testing</h4><p>After being a career-long skeptic of the test-first, maximum test coverage school of software development (I like <a href=\"https://simonwillison.net/2022/Oct/29/the-perfect-commit/#tests\">tests included</a> development instead) I’ve recently come around to test-first processes as a way to force agents to write only the code that’s necessary to solve the problem at hand.</p><p>Many of my Python coding agent sessions start the same way:</p><blockquote><p><code>Run the existing tests with \"uv run pytest\". Build using red/green TDD.</code></p></blockquote><p>Telling the agents how to run the tests doubles as an indicator that tests on this project exist and matter. Agents will read existing tests before writing their own so having a clean test suite with good patterns makes it more likely they’ll write good tests of their own.</p><p>The frontier models all understand that “red/green TDD” means they should write the test first, run it and watch it fail and then write the code to make it pass—it’s a convenient shortcut.</p><p>I find this greatly increases the quality of the code and the likelihood that the agent will produce the right thing with the smallest amount of prompts to guide it.</p><p>But anyone who’s worked with tests will know that just because the automated tests pass doesn’t mean the software actually works! That’s the motivation behind Showboat and Rodney—I never trust any feature until I’ve seen it running with my own eye.</p><p>Before building Showboat I’d often add a “manual” testing step to my agent sessions, something like:</p><blockquote><p><code>Once the tests pass, start a development server and exercise the new feature using curl</code></p></blockquote><p>Both Showboat and Rodney started life as Claude Code for web projects created via the Claude iPhone app. Most of the ongoing feature work for them happened in the same way.</p><p>I’m still a little startled at how much of my coding work I get done on my phone now, but I’d estimate that the majority of code I ship to GitHub these days was written for me by coding agents driven via that iPhone app.</p><p>I initially designed these two tools for use in asynchronous coding agent environments like Claude Code for the web. So far that’s working out really well.</p>","contentLength":8072,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46963887"},{"title":"Show HN: Stripe-no-webhooks – Sync your Stripe data to your Postgres DB","url":"https://github.com/pretzelai/stripe-no-webhooks","date":1770743688,"author":"prasoonds","guid":202,"unread":true,"content":"<p>Why is this useful? (1) You don't have to figure out which webhooks you need or write listeners for each one. The library handles all of that. This follows the approach of libraries like dj-stripe in the Django world (<a href=\"https://dj-stripe.dev/\" rel=\"nofollow\">https://dj-stripe.dev/</a>). (2) Stripe's API has a 100 rpm rate limit. If you're checking subscription status frequently or building internal tools, you'll hit it. Querying your own Postgres doesn't have this problem. (3) You can give an AI agent read access to the stripe.* schema to debug payment issues—failed charges, refunds, whatever—without handing over Stripe dashboard access. (4) You can join Stripe data with your own tables for custom analytics, LTV calculations, etc.</p><p>It creates a webhook endpoint in your Stripe account to forward webhooks to your backend where a webhook listener stores all the data into a new  schema. You define your plans in TypeScript, run a sync command, and the library takes care of creating Stripe products and prices, handling webhooks, and keeping your database in sync. We also let you backfill your Stripe data for existing accounts.</p><p>It supports pre-paid usage credits, account wallets and usage-based billing. It also lets you generate a pricing table component that you can customize. You can access the user information using the simple API the library provides:</p><pre><code>  billing.subscriptions.get({ userId });\n  billing.credits.consume({ userId, key: \"api_calls\", amount: 1 });\n  billing.usage.record({ userId, key: \"ai_model_tokens_input\", amount: 4726 });\n</code></pre>\nEffectively, you don't have to deal with either the Stripe dashboard or the Stripe API/SDK any more if you don't want to. The library gives you a nice abstraction on top of Stripe that should cover ~most subscription payment use-cases.<p>Let's see how it works with a quick example. Say you have a billing plan like Cursor (the IDE) used to have: $20/mo, you get 500 API completions + 2000 tab completions, you can buy additional API credits, and any additional usage is billed as overage.</p><p>You define your plan in TypeScript:</p><pre><code>  {\n    name: \"Pro\",\n    description: \"Cursor Pro plan\",\n    price: [{ amount: 2000, currency: \"usd\", interval: \"month\" }],\n    features: {\n      api_completion: {\n        pricePerCredit: 1,              // 1 cent per unit\n        trackUsage: true,               // Enable usage billing\n        credits: { allocation: 500 },\n        displayName: \"API Completions\",\n      },\n      tab_completion: {\n        credits: { allocation: 2000 },\n        displayName: \"Tab Completions\",\n      },\n    },\n  }\n</code></pre>\nThen on the CLI, you run the `init` command which creates the DB tables + some API handlers. Run `sync` to sync the plans to your Stripe account and create a webhook endpoint. When a subscription is created, the library automatically grants the 500 API completion credits and 2000 tab completion credits to the user. Renewals and up/downgrades are handled sanely.<p>Consume code would look like this:</p><pre><code>  await billing.credits.consume({\n    userId: user.id,\n    key: \"api_completion\",\n    amount: 1,\n  });\n</code></pre>\nAnd if they want to allow manual top-ups by the user:<pre><code>  await billing.credits.topUp({\n    userId: user.id,\n    key: \"api_completion\",\n    amount: 500,     // buy 500 credits, charges $5.00\n  });\n</code></pre>\nSimilarly, we have APIs for wallets and usage.<p>This would be a lot of work to implement by yourself on top of Stripe. You need to keep track of all of these entitlements in your own DB and deal with renewals, expiry, ad-hoc grants, etc. It's definitely doable, especially with AI coding, but you'll probably end up building something fragile and hard to maintain.</p><p>This is just a high-level overview of what the library is capable of. It also supports seat-level credits, monetary wallets (with micro-cent precision), auto top-ups, robust failure recovery, tax collection, invoices, and an out-of-the-box pricing table.</p><p>I vibe-coded a little toy app for testing: <a href=\"https://snw-test.vercel.app\" rel=\"nofollow\">https://snw-test.vercel.app</a>. There's no validation so feel free to sign up with a dummy email, then subscribe to a plan with a test card: 4242 4242 4242 4242, any future expiry, any 3-digit CVV.</p><p>Feel free to try it out! If you end up using this library, please report any bugs on the repo. If you're having trouble / want to chat, I'm happy to help - my contact is in my HN profile.</p>","contentLength":4271,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46963177"},{"title":"Show HN: I made paperboat.website, a platform for friends and creativity","url":"https://paperboat.website/home/","date":1770742672,"author":"yethiel","guid":201,"unread":true,"content":"<p><em>A simple, friendly and accessible personal site or blog for your thoughts, projects and creations.</em></p><p>The internet is full of distractions and advertisements, and I felt like there needed to be a place on the web for me and my friends.\nI called it paperboat because it is simple, lightweight, and friendly. I also like to imagine a little stream full of paperboats, each carrying a special and personal story.\nYou’re warmly invited to be part of it!</p><h2>What do sites on paperboat.website look like?</h2><h2>The most important things</h2><ol><li>Create your own personal site</li><li>Use <a href=\"https://webrings.paperboat.website\">webrings</a> to explore and find new sites</li><li>Choose between rich text editing and markdown</li><li>Accessible and keyboard-friendly</li></ol><p><strong>Support paperboat.website</strong> (5€ to keep the boat afloat) and:</p><ol><li>Invite 3 friends for free</li><li>Upload images to your blog posts</li><li>Choose a custom color theme</li></ol><p>I’m always looking for ways to make paperboat.website more friendly, more accessible, and more the way you and I like it.\nLet me know if something doesn’t work for you or if you’re missing something.\nSend an email to <a href=\"mailto:mail@paperboat.website\">mail@paperboat.website</a></p><p>paperboat.website is hosted and maintained by <a href=\"https://marvinthiel.com\">Marv</a> from Leipzig, Germany.</p><p>Create your account and start sharing your stories with your friends and the world.\nNo complicated setup, no distractions.</p>","contentLength":1250,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46962871"},{"title":"Show HN: Rowboat – AI coworker that turns your work into a knowledge graph (OSS)","url":"https://github.com/rowboatlabs/rowboat","date":1770742049,"author":"segmenta","guid":200,"unread":true,"content":"<p>AI agents that can run tools on your machine are powerful for knowledge work, but they’re only as useful as the context they have. Rowboat is an open-source, local-first app that turns your work into a living knowledge graph (stored as plain Markdown with backlinks) and uses it to accomplish tasks on your computer.</p><p>For example, you can say \"Build me a deck about our next quarter roadmap.\" Rowboat pulls priorities and commitments from your graph, loads a presentation skill, and exports a PDF.</p><p>(1) A living context graph: Rowboat connects to sources like Gmail and meeting notes like Granola and Fireflies, extracts decisions, commitments, deadlines, and relationships, and writes them locally as linked and editable Markdown files (Obsidian-style), organized around people, projects, and topics. As new conversations happen (including voice memos), related notes update automatically. If a deadline changes in a standup, it links back to the original commitment and updates it.</p><p>(2) A local assistant: On top of that graph, Rowboat includes an agent with local shell access and MCP support, so it can use your existing context to actually do work on your machine. It can act on demand or run scheduled background tasks. Example: “Prep me for my meeting with John and create a short voice brief.” It pulls relevant context from your graph and can generate an audio note via an MCP tool like ElevenLabs.</p><p>Why not just search transcripts? Passing gigabytes of email, docs, and calls directly to an AI agent is slow and lossy. And search only answers the questions you think to ask. A system that accumulates context over time can track decisions, commitments, and relationships across conversations, and surface patterns you didn't know to look for.</p><p>Rowboat is Apache-2.0 licensed, works with any LLM (including local ones), and stores all data locally as Markdown you can read, edit, or delete at any time.</p><p>Our previous startup was acquired by Coinbase, where part of my work involved graph neural networks. We're excited to be working with graph-based systems again. Work memory feels like the missing layer for agents.</p><p>We’d love to hear your thoughts and welcome contributions!</p>","contentLength":2180,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=46962641"}],"tags":["dev","hn"]}