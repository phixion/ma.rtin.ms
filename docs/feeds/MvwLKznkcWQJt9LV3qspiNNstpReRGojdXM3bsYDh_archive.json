{"id":"MvwLKznkcWQJt9LV3qspiNNstpReRGojdXM3bsYDh","title":"Kubernetes Blog","displayTitle":"Dev - Kubernetes Blog","url":"https://kubernetes.io/feed.xml","feedLink":"https://kubernetes.io/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":3,"items":[{"title":"7 Common Kubernetes Pitfalls (and How I Learned to Avoid Them)","url":"https://kubernetes.io/blog/2025/10/20/seven-kubernetes-pitfalls-and-how-to-avoid/","date":1760974200,"author":"","guid":706,"unread":true,"content":"<p>It’s no secret that Kubernetes can be both powerful and frustrating at times. When I first started dabbling with container orchestration, I made more than my fair share of mistakes enough to compile a whole list of pitfalls. In this post, I want to walk through seven big gotchas I’ve encountered (or seen others run into) and share some tips on how to avoid them. Whether you’re just kicking the tires on Kubernetes or already managing production clusters, I hope these insights help you steer clear of a little extra stress.</p><h2>1. Skipping resource requests and limits</h2><p>: Not specifying CPU and memory requirements in Pod specifications. This typically happens because Kubernetes does not require these fields, and workloads can often start and run without them—making the omission easy to overlook in early configurations or during rapid deployment cycles.</p><p>:\nIn Kubernetes, resource requests and limits are critical for efficient cluster management. Resource requests ensure that the scheduler reserves the appropriate amount of CPU and memory for each pod, guaranteeing that it has the necessary resources to operate. Resource limits cap the amount of CPU and memory a pod can use, preventing any single pod from consuming excessive resources and potentially starving other pods.\nWhen resource requests and limits are not set:</p><ol><li>Resource Starvation: Pods may get insufficient resources, leading to degraded performance or failures. This is because Kubernetes schedules pods based on these requests. Without them, the scheduler might place too many pods on a single node, leading to resource contention and performance bottlenecks.</li><li>Resource Hoarding: Conversely, without limits, a pod might consume more than its fair share of resources, impacting the performance and stability of other pods on the same node. This can lead to issues such as other pods getting evicted or killed by the Out-Of-Memory (OOM) killer due to lack of available memory.</li></ol><ul><li>Start with modest  (for example  CPU,  memory) and see how your app behaves.</li><li>Monitor real-world usage and refine your values; the <a href=\"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/\">HorizontalPodAutoscaler</a> can help automate scaling based on metrics.</li><li>Keep an eye on  or your logging/monitoring tool to confirm you’re not over- or under-provisioning.</li></ul><p>: Early on, I never thought about memory limits. Things seemed fine on my local cluster. Then, on a larger environment, Pods got  left and right. Lesson learned.\nFor detailed instructions on configuring resource requests and limits for your containers, please refer to <a href=\"https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/\">Assign Memory Resources to Containers and Pods</a>\n(part of the official Kubernetes documentation).</p><h2>2. Underestimating liveness and readiness probes</h2><p>: Deploying containers without explicitly defining how Kubernetes should check their health or readiness. This tends to happen because Kubernetes will consider a container “running” as long as the process inside hasn’t exited. Without additional signals, Kubernetes assumes the workload is functioning—even if the application inside is unresponsive, initializing, or stuck.</p><p>:\nLiveness, readiness, and startup probes are mechanisms Kubernetes uses to monitor container health and availability.</p><ul><li> determine if the application is still alive. If a liveness check fails, the container is restarted.</li><li> control whether a container is ready to serve traffic. Until the readiness probe passes, the container is removed from Service endpoints.</li><li> help distinguish between long startup times and actual failures.</li></ul><ul><li>Add a simple HTTP  to check a health endpoint (for example ) so Kubernetes can restart a hung container.</li><li>Use a  to ensure traffic doesn’t reach your app until it’s warmed up.</li><li>Keep probes simple. Overly complex checks can create false alarms and unnecessary restarts.</li></ul><p>: I once forgot a readiness probe for a web service that took a while to load. Users hit it prematurely, got weird timeouts, and I spent hours scratching my head. A 3-line readiness probe would have saved the day.</p><h2>3. “We’ll just look at container logs” (famous last words)</h2><p>: Relying solely on container logs retrieved via . This often happens because the command is quick and convenient, and in many setups, logs appear accessible during development or early troubleshooting. However,  only retrieves logs from currently running or recently terminated containers, and those logs are stored on the node’s local disk. As soon as the container is deleted, evicted, or the node is restarted, the log files may be rotated out or permanently lost.</p><ul><li> using CNCF tools like <a href=\"https://kubernetes.io/docs/concepts/cluster-administration/logging/#sidecar-container-with-a-logging-agent\">Fluentd</a> or <a href=\"https://fluentbit.io/\">Fluent Bit</a> to aggregate output from all Pods.</li><li> for a unified view of logs, metrics, and (if needed) traces. This lets you spot correlations between infrastructure events and app-level behavior.</li><li><strong>Pair logs with Prometheus metrics</strong> to track cluster-level data alongside application logs. If you need distributed tracing, consider CNCF projects like <a href=\"https://www.jaegertracing.io/\">Jaeger</a>.</li></ul><p>: The first time I lost Pod logs to a quick restart, I realized how flimsy “kubectl logs” can be on its own. Since then, I’ve set up a proper pipeline for every cluster to avoid missing vital clues.</p><h2>4. Treating dev and prod exactly the same</h2><p>: Deploying the same Kubernetes manifests with identical settings across development, staging, and production environments. This often occurs when teams aim for consistency and reuse, but overlook that environment-specific factors—such as traffic patterns, resource availability, scaling needs, or access control—can differ significantly. Without customization, configurations optimized for one environment may cause instability, poor performance, or security gaps in another.</p><ul><li>Use environment overlays or <a href=\"https://kustomize.io/\">kustomize</a> to maintain a shared base while customizing resource requests, replicas, or config for each environment.</li><li>Extract environment-specific configuration into ConfigMaps and / or Secrets. You can use a specialized tool such as <a href=\"https://github.com/bitnami-labs/sealed-secrets\">Sealed Secrets</a> to manage confidential data.</li><li>Plan for scale in production. Your dev cluster can probably get away with minimal CPU/memory, but prod might need significantly more.</li></ul><p>: One time, I scaled up  from 2 to 10 in a tiny dev environment just to “test.” I promptly ran out of resources and spent half a day cleaning up the aftermath. Oops.</p><h2>5. Leaving old stuff floating around</h2><p>: Leaving unused or outdated resources—such as Deployments, Services, ConfigMaps, or PersistentVolumeClaims—running in the cluster. This often happens because Kubernetes does not automatically remove resources unless explicitly instructed, and there is no built-in mechanism to track ownership or expiration. Over time, these forgotten objects can accumulate, consuming cluster resources, increasing cloud costs, and creating operational confusion, especially when stale Services or LoadBalancers continue to route traffic.</p><ul><li> with a purpose or owner label. That way, you can easily query resources you no longer need.</li><li> your cluster: run <code>kubectl get all -n &lt;namespace&gt;</code> to see what’s actually running, and confirm it’s all legit.</li><li><strong>Adopt Kubernetes’ Garbage Collection</strong>: <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/\">K8s docs</a> show how to remove dependent objects automatically.</li><li><strong>Leverage policy automation</strong>: Tools like <a href=\"https://kyverno.io/\">Kyverno</a> can automatically delete or block stale resources after a certain period, or enforce lifecycle policies so you don’t have to remember every single cleanup step.</li></ul><p>: After a hackathon, I forgot to tear down a “test-svc” pinned to an external load balancer. Three weeks later, I realized I’d been paying for that load balancer the entire time. Facepalm.</p><h2>6. Diving too deep into networking too soon</h2><p>: Introducing advanced networking solutions—such as service meshes, custom CNI plugins, or multi-cluster communication—before fully understanding Kubernetes' native networking primitives. This commonly occurs when teams implement features like traffic routing, observability, or mTLS using external tools without first mastering how core Kubernetes networking works: including Pod-to-Pod communication, ClusterIP Services, DNS resolution, and basic ingress traffic handling. As a result, network-related issues become harder to troubleshoot, especially when overlays introduce additional abstractions and failure points.</p><ul><li>Start small: a Deployment, a Service, and a basic ingress controller such as one based on NGINX (e.g., Ingress-NGINX).</li><li>Make sure you understand how traffic flows within the cluster, how service discovery works, and how DNS is configured.</li><li>Only move to a full-blown mesh or advanced CNI features when you actually need them, complex networking adds overhead.</li></ul><p>: I tried Istio on a small internal app once, then spent more time debugging Istio itself than the actual app. Eventually, I stepped back, removed Istio, and everything worked fine.</p><h2>7. Going too light on security and RBAC</h2><p>: Deploying workloads with insecure configurations, such as running containers as the root user, using the  image tag, disabling security contexts, or assigning overly broad RBAC roles like . These practices persist because Kubernetes does not enforce strict security defaults out of the box, and the platform is designed to be flexible rather than opinionated. Without explicit security policies in place, clusters can remain exposed to risks like container escape, unauthorized privilege escalation, or accidental production changes due to unpinned images.</p><ul><li>Use <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\">RBAC</a> to define roles and permissions within Kubernetes. While RBAC is the default and most widely supported authorization mechanism, Kubernetes also allows the use of alternative authorizers. For more advanced or external policy needs, consider solutions like <a href=\"https://open-policy-agent.github.io/gatekeeper/\">OPA Gatekeeper</a> (based on Rego), <a href=\"https://kyverno.io/\">Kyverno</a>, or custom webhooks using policy languages such as CEL or <a href=\"https://cedarpolicy.com/\">Cedar</a>.</li><li>Pin images to specific versions (no more !). This helps you know what’s actually deployed.</li><li>Look into <a href=\"https://kubernetes.io/docs/concepts/security/pod-security-admission/\">Pod Security Admission</a> (or other solutions like Kyverno) to enforce non-root containers, read-only filesystems, etc.</li></ul><p>: I never had a huge security breach, but I’ve heard plenty of cautionary tales. If you don’t tighten things up, it’s only a matter of time before something goes wrong.</p><p>Kubernetes is amazing, but it’s not psychic, it won’t magically do the right thing if you don’t tell it what you need. By keeping these pitfalls in mind, you’ll avoid a lot of headaches and wasted time. Mistakes happen (trust me, I’ve made my share), but each one is a chance to learn more about how Kubernetes truly works under the hood.\nIf you’re curious to dive deeper, the <a href=\"https://kubernetes.io/docs/home/\">official docs</a> and the <a href=\"http://slack.kubernetes.io/\">community Slack</a> are excellent next steps. And of course, feel free to share your own horror stories or success tips, because at the end of the day, we’re all in this cloud native adventure together.</p>","contentLength":10623,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Spotlight on Policy Working Group","url":"https://kubernetes.io/blog/2025/10/18/wg-policy-spotlight-2025/","date":1760745600,"author":"","guid":705,"unread":true,"content":"<p><em>(Note: The Policy Working Group has completed its mission and is no longer active. This article reflects its work, accomplishments, and insights into how a working group operates.)</em></p><p>In the complex world of Kubernetes, policies play a crucial role in managing and securing clusters. But have you ever wondered how these policies are developed, implemented, and standardized across the Kubernetes ecosystem? To answer that, let's take a look back at the work of the Policy Working Group.</p><p>The Policy Working Group was dedicated to a critical mission: providing an overall architecture that encompasses both current policy-related implementations and future policy proposals in Kubernetes. Their goal was both ambitious and essential: to develop a universal policy architecture that benefits developers and end-users alike.</p><p>Through collaborative methods, this working group strove to bring clarity and consistency to the often complex world of Kubernetes policies. By focusing on both existing implementations and future proposals, they ensured that the policy landscape in Kubernetes remains coherent and accessible as the technology evolves.</p><p>This blog post dives deeper into the work of the Policy Working Group, guided by insights from its former co-chairs:</p><p>These co-chairs explained what the Policy Working Group was all about.</p><p><strong>Hello, thank you for the time! Let’s start with some introductions, could you tell us a bit about yourself, your role, and how you got involved in Kubernetes?</strong></p><p>: My name is Jim Bugwadia, and I am a co-founder and the CEO at Nirmata which provides solutions that automate security and compliance for cloud-native workloads. At Nirmata, we have been working with Kubernetes since it started in 2014. We initially built a Kubernetes policy engine in our commercial platform and later donated it to CNCF as the Kyverno project. I joined the CNCF Kubernetes Policy Working Group to help build and standardize various aspects of policy management for Kubernetes and later became a co-chair.</p><p>: My name is Andy Suderman and I am the CTO of Fairwinds, a managed Kubernetes-as-a-Service provider. I began working with Kubernetes in 2016 building a web conferencing platform. I am an author and/or maintainer of several Kubernetes-related open-source projects such as Goldilocks, Pluto, and Polaris. Polaris is a JSON-schema-based policy engine, which started Fairwinds' journey into the policy space and my involvement in the Policy Working Group.</p><p>: My name is Poonam Lamba, and I currently work as a Product Manager for Google Kubernetes Engine (GKE) at Google. My journey with Kubernetes began back in 2017 when I was building an SRE platform for a large enterprise, using a private cloud built on Kubernetes. Intrigued by its potential to revolutionize the way we deployed and managed applications at the time, I dove headfirst into learning everything I could about it. Since then, I've had the opportunity to build the policy and compliance products for GKE. I lead and contribute to GKE CIS benchmarks. I am involved with the Gatekeeper project as well as I have contributed to Policy-WG for over 2 years and served as a co-chair for the group.</p><p><em>Responses to the following questions represent an amalgamation of insights from the former co-chairs.</em></p><p><strong>One thing even I am not aware of is the difference between a working group and a SIG. Can you help us understand what a working group is and how it is different from a SIG?</strong></p><p>Unlike SIGs, working groups are temporary and focused on tackling specific, cross-cutting issues or projects that may involve multiple SIGs. Their lifespan is defined, and they disband once they've achieved their objective. Generally, working groups don't own code or have long-term responsibility for managing a particular area of the Kubernetes project.</p><p><strong>You mentioned that Working Groups involve multiple SIGS. What SIGS was the Policy WG closely involved with, and how did you coordinate with them?</strong></p><p>The group collaborated closely with Kubernetes SIG Auth throughout our existence, and more recently, the group also worked with SIG Security since its formation. Our collaboration occurred in a few ways. We provided periodic updates during the SIG meetings to keep them informed of our progress and activities. Additionally, we utilize other community forums to maintain open lines of communication and ensured our work aligned with the broader Kubernetes ecosystem. This collaborative approach helped the group stay coordinated with related efforts across the Kubernetes community.</p><p><strong>Why was the Policy Working Group created?</strong></p><p>To enable a broad set of use cases, we recognize that Kubernetes is powered by a highly declarative, fine-grained, and extensible configuration management system. We've observed that a Kubernetes configuration manifest may have different portions that are important to various stakeholders. For example, some parts may be crucial for developers, while others might be of particular interest to security teams or address operational concerns. Given this complexity, we believe that policies governing the usage of these intricate configurations are essential for success with Kubernetes.</p><p>Our Policy Working Group was created specifically to research the standardization of policy definitions and related artifacts. We saw a need to bring consistency and clarity to how policies are defined and implemented across the Kubernetes ecosystem, given the diverse requirements and stakeholders involved in Kubernetes deployments.</p><p><strong>Can you give me an idea of the work you did in the group?</strong></p><p>We worked on several Kubernetes policy-related projects. Our initiatives included:</p><ul><li>We worked on a Kubernetes Enhancement Proposal (KEP) for the Kubernetes Policy Reports API. This aims to standardize how policy reports are generated and consumed within the Kubernetes ecosystem.</li><li>We conducted a CNCF survey to better understand policy usage in the Kubernetes space. This helped gauge the practices and needs across the community at the time.</li><li>We wrote a paper that will guide users in achieving PCI-DSS compliance for containers. This is intended to help organizations meet important security standards in their Kubernetes environments.</li><li>We also worked on a paper highlighting how shifting security down can benefit organizations. This focuses on the advantages of implementing security measures earlier in the development and deployment process.</li></ul><p><strong>Can you tell us what were the main objectives of the Policy Working Group and some of your key accomplishments?</strong></p><p>The charter of the Policy WG was to help standardize policy management for Kubernetes and educate the community on best practices.</p><p>To accomplish this we updated the Kubernetes documentation (<a href=\"https://kubernetes.io/docs/concepts/policy\">Policies | Kubernetes</a>), produced several whitepapers (<a href=\"https://github.com/kubernetes/sig-security/blob/main/sig-security-docs/papers/policy/CNCF_Kubernetes_Policy_Management_WhitePaper_v1.pdf\">Kubernetes Policy Management</a>, <a href=\"https://github.com/kubernetes/sig-security/blob/main/sig-security-docs/papers/policy_grc/Kubernetes_Policy_WG_Paper_v1_101123.pdf\">Kubernetes GRC</a>), and created the Policy Reports API (<a href=\"https://github.com/kubernetes-retired/wg-policy-prototypes/blob/master/policy-report/docs/api-docs.md\">API reference</a>) which standardizes reporting across various tools. Several popular tools such as Falco, Trivy, Kyverno, kube-bench, and others support the Policy Report API. A major milestone for the Policy WG was promoting the Policy Reports API to a SIG-level API or finding it a stable home.</p><p>Beyond that, as <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/validating-admission-policy/\">ValidatingAdmissionPolicy</a> and <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/mutating-admission-policy/\">MutatingAdmissionPolicy</a> approached GA in Kubernetes, a key goal of the WG was to guide and educate the community on the tradeoffs and appropriate usage patterns for these built-in API objects and other CNCF policy management solutions like OPA/Gatekeeper and Kyverno.</p><p><strong>What were some of the major challenges that the Policy Working Group worked on?</strong></p><p>During our work in the Policy Working Group, we encountered several challenges:</p><ul><li><p>One of the main issues we faced was finding time to consistently contribute. Given that many of us have other professional commitments, it can be difficult to dedicate regular time to the working group's initiatives.</p></li><li><p>Another challenge we experienced was related to our consensus-driven model. While this approach ensures that all voices are heard, it can sometimes lead to slower decision-making processes. We valued thorough discussion and agreement, but this can occasionally delay progress on our projects.</p></li><li><p>We've also encountered occasional differences of opinion among group members. These situations require careful navigation to ensure that we maintain a collaborative and productive environment while addressing diverse viewpoints.</p></li><li><p>Lastly, we've noticed that newcomers to the group may find it difficult to contribute effectively without consistent attendance at our meetings. The complex nature of our work often requires ongoing context, which can be challenging for those who aren't able to participate regularly.</p></li></ul><p><strong>Can you tell me more about those challenges? How did you discover each one? What has the impact been? What were some strategies you used to address them?</strong></p><p>There are no easy answers, but having more contributors and maintainers greatly helps! Overall the CNCF community is great to work with and is very welcoming to beginners. So, if folks out there are hesitating to get involved, I highly encourage them to attend a WG or SIG meeting and just listen in.</p><p>It often takes a few meetings to fully understand the discussions, so don't feel discouraged if you don't grasp everything right away. We made a point to emphasize this and encouraged new members to review documentation as a starting point for getting involved.</p><p>Additionally, differences of opinion were valued and encouraged within the Policy-WG. We adhered to the CNCF core values and resolve disagreements by maintaining respect for one another. We also strove to timebox our decisions and assign clear responsibilities to keep things moving forward.</p><p>This is where our discussion about the Policy Working Group ends. The working group, and especially the people who took part in this article, hope this gave you some insights into the group's aims and workings. You can get more info about Working Groups <a href=\"https://github.com/kubernetes/community/blob/master/committee-steering/governance/wg-governance.md\">here</a>.</p>","contentLength":9857,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Introducing Headlamp Plugin for Karpenter - Scaling and Visibility","url":"https://kubernetes.io/blog/2025/10/06/introducing-headlamp-plugin-for-karpenter/","date":1759708800,"author":"","guid":704,"unread":true,"content":"<p>Headlamp is an open‑source, extensible Kubernetes SIG UI project designed to let you explore, manage, and debug cluster resources.</p><p>Karpenter is a Kubernetes Autoscaling SIG node provisioning project that helps clusters scale quickly and efficiently. It launches new nodes in seconds, selects appropriate instance types for workloads, and manages the full node lifecycle, including scale-down.</p><p>The new Headlamp Karpenter Plugin adds real-time visibility into Karpenter’s activity directly from the Headlamp UI. It shows how Karpenter resources relate to Kubernetes objects, displays live metrics, and surfaces scaling events as they happen. You can inspect pending pods during provisioning, review scaling decisions, and edit Karpenter-managed resources with built-in validation. The Karpenter plugin was made as part of a LFX mentor project.</p><p>The Karpenter plugin for Headlamp aims to make it easier for Kubernetes users and operators to understand, debug, and fine-tune autoscaling behavior in their clusters. Now we will give a brief tour of the Headlamp plugin.</p><h2>Map view of Karpenter Resources and how they relate to Kubernetes resources</h2><p>Easily see how Karpenter Resources like NodeClasses, NodePool and NodeClaims connect with core Kubernetes resources like Pods, Nodes etc.</p><h2>Visualization of Karpenter Metrics</h2><p>Get instant insights of Resource Usage v/s Limits, Allowed disruptions, Pending Pods, Provisioning Latency and many more .</p><p>Shows which instances are being provisioned for your workloads and understand the reason behind why Karpenter made those choices. Helpful while debugging.</p><h2>Config editor with validation support</h2><p>Make live edits to Karpenter configurations. The editor includes diff previews and resource validation for safer adjustments.<img alt=\"Config editor with validation support\" src=\"https://kubernetes.io/blog/2025/10/06/introducing-headlamp-plugin-for-karpenter/config-editor.png\"></p><h2>Real time view of Karpenter resources</h2><p>View and track Karpenter specific resources in real time such as “NodeClaims” as your cluster scales up and down.</p><h2>Dashboard for Pending Pods</h2><p>View all pending pods with unmet scheduling requirements/Failed Scheduling highlighting why they couldn't be scheduled.</p><p>This plugin should work with most Karpenter providers, but has only so far been tested on the ones listed in the table. Additionally, each provider gives some extra information, and the ones in the table below are displayed by the plugin.</p><p>Please <a href=\"https://github.com/headlamp-k8s/plugins/issues\">submit an issue</a> if you test one of the untested providers or if you want support for this provider (PRs also gladly accepted).</p>","contentLength":2418,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","k8s"]}