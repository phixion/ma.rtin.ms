{"id":"4W3i2hyrJTVfcLq85rWgduVQ3y3BMzrSD4pVUCMqPpFhmXWpqxQ","title":"Hacker News: Front Page","displayTitle":"HN Front","url":"https://hnrss.org/frontpage?points=75","feedLink":"https://news.ycombinator.com/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":4,"items":[{"title":"GHC now runs in the browser","url":"https://discourse.haskell.org/t/ghc-now-runs-in-your-browser/13169","date":1762014563,"author":"kaycebasques","guid":196,"unread":true,"content":"<div itemprop=\"text\"><p>thanks for the reports! a few seconds of freeze during start-time is expected, since it needs to download ~50M of a rootfs tarball and extract it, then link the ghc library and all its dependencies. as for safari, it’s strange since i i just landed a workaround for a webkit bug that breaks the wasm dynamic linker a few days ago, i’ll take a closer look later.</p></div>","contentLength":365,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=45782981"},{"title":"CharlotteOS – An Experimental Modern Operating System","url":"https://github.com/charlotte-os/Catten","date":1762002767,"author":"ementally","guid":194,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=45781397"},{"title":"SQLite concurrency and why you should care about it","url":"https://jellyfin.org/posts/SQLite-locking/","date":1762001943,"author":"HunOL","guid":193,"unread":true,"content":"<p>SQLite is a powerful database engine, but due to its design, it has limitations that should not be overlooked.</p><p>Jellyfin has used a SQLite-based database for storing most of its data for years, but it has also encountered issues on many systems. In this blog post, I will explain how we address these limitations and how developers using SQLite can apply the same solutions.</p><p>This will be a technical blog post intended for developers and everyone wanting to learn about concurrency.</p><p>Also Jellyfin's implementation of locking for SQLite should be fairly easy to be implemented into another EF Core application if you are facing the same issue.</p><p>SQLite is a file-based database engine running within your application and allows you to store data in a relational structure.\nOverall it gives your application the means of storing structured data as a single file and without having to depend on another application to do so.\nNaturally this also comes at a price. If your application fully manages this file, the assumption must be made that your application is the sole owner of this file, and nobody else will tinker with it while you are writing data to it.</p><p>So an application that wants to use SQLite as its database needs to be the only one accessing it.\nHaving established this fact, an important thought arises: if only a single write operation should be performed on a single file at a time, this rule must also apply to operations within the same application.</p><p>SQLite has a feature that tries to get around this limitation: the Write-Ahead-Log (WAL).\nThe WAL is a separate file that acts as a journal of operations that should be applied to an SQLite file.\nThis allows multiple parallel writes to take place and get enqueued into the WAL.\nWhen another part of the application wants to read data, it reads from the actual database, then scans the WAL for modifications and applies them on the fly.\nThis is not a foolproof solution; there are still scenarios where WAL does not prevent locking conflicts.</p><p>A transaction is supposed to ensure two things.\nModifications made within a transaction can be reverted, either when something goes wrong or when the application decides it should and optionally a transaction may also block other readers from reading data that is modified within a transaction.\nThis is where it gets spicy and we come to the real reason why I am writing this blog post.\nFor some reason on some systems that run Jellyfin when a transaction takes place the SQLite engine reports the database is locked and instead of waiting for the transaction to be resolved the engine refuses to wait and just crashes.\nThis seems to be a not uncommon issue and there are many reports to be found on the issue.</p><p>The factor that makes this issue so bad is that it does not happen reliably. So far we only have one team member where this can be (somewhat) reliably be reproduced which makes this an even worse a bug.\nFrom the reports this issue happens across all operating systems, drive speeds and with or without virtualization.\nSo we do not have any deciding factor identified that even contributes to the likelihood of the issue happening.</p><p>Having established the general theory on how SQLite behaves, we also have to look at the specifics of Jellyfins usage of SQLite.\nDuring normal operations on a recommended setup (Non-Networked Storage and preferably SSD) its unusual for any problems to arise, however the way Jellyfin utilises the SQLite db up to 10.11 is very suboptimal.\nIn versions prior to 10.11 Jellyfin had a bug in its parallel task limit which resulted in exponential overscheduling of library scan operations which hammered the database engine with thousands of parallel write requests that an SQLite engine is simply not able to handle.\nWhile most SQLite engine implementations have retry behavior, they also have timeouts and checks in place to prevent limitless waiting so if we stress the engine enough, it just fails with an error.\nThat and very long running and frankly unoptimized transactions could lead to the database just being overloaded with requests and flaking out.</p><p>Since we moved the codebase over to EF Core proper, we have the tools to actually do something about this as EF Core gives us a structured abstraction level.\nEF Core supports a way of hooking into every command execution or transaction by creating <a href=\"https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/interceptors\" target=\"_blank\" rel=\"noopener noreferrer\">Interceptors</a>.\nWith an interceptor we can finally do the straight forward idea of just \"not\" writing to the database in parallel in a transparent way to the caller.\nThe overall idea is to have multiple strategies of locking. Because all levels of synchronization will inevitably come at the cost of performance, we only want to do it when it is really necessary.\nSo, I decided on three locking strategies:</p><ol></ol><p>As a default, the no-lock behavior does exactly what the name implies. Nothing. This is the default because my research shows that for 99% all of this is not an issue and every interaction at this level will slow down the whole application.</p><p>Both the optimistic and pessimistic behaviors use two interceptors—one for transactions and one for commands—and override  in .</p><h3>Optimistic locking behavior<a href=\"https://jellyfin.org/posts/SQLite-locking/#optimistic-locking-behavior\" aria-label=\"Direct link to Optimistic locking behavior\" title=\"Direct link to Optimistic locking behavior\" translate=\"no\">​</a></h3><p>Optimistic locking means to assume the operation in question will succeed and only handle issues afterwards. In essence this can be boiled down to \"Try and Retry and Retry ...\" for a set number of times until either we succeed with the operation or fail entirely.\nThis still leaves the possibility that we will not actually be able to perform a write, but the introduced overhead is far less than the Pessimistic locking behavior.</p><p>The idea behind how this works is simple: every time two operations try to write to the database, one will always win. The other will fail, wait some time, then retry a few times.</p><p>Jellyfin uses the  library perform the retry behavior and will only retry operations it will find have been locked due to this exact issue.</p><h3>Pessimistic locking behavior<a href=\"https://jellyfin.org/posts/SQLite-locking/#pessimistic-locking-behavior\" aria-label=\"Direct link to Pessimistic locking behavior\" title=\"Direct link to Pessimistic locking behavior\" translate=\"no\">​</a></h3><p>Pessimistic locking always locks when a write to SQLite should be performed. Essentially every time an transaction is started or a write operation on the database is done though EF Core, Jellyfin will wait until all other read operations are finished and then block all other operations may they be read or write until the write in question has been performed.\nThis however means, that Jellyfin can only ever perform a single write to the database, even if it would technically does not need to.</p><p>In theory, an application should have no issue reading from table \"Alice\" while writing to table \"Bob\" however to eliminate all possible sources of concurrency related locking, Jellyfin will only ever allow a single write performed on its database in this mode.\nWhile this will absolutely result in the most stable operation, it will undoubtedly also be the slowest.</p><p>Jellyfin uses a <a href=\"https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-threading-readerwriterlockslim\" target=\"_blank\" rel=\"noopener noreferrer\">ReaderWriterLockSlim</a> to lock the operations, that means we allow an unlimited number of reads to happen concurrently while only one write may ever be done on the database.</p><h3>The future Smart locking behavior<a href=\"https://jellyfin.org/posts/SQLite-locking/#the-future-smart-locking-behavior\" aria-label=\"Direct link to The future Smart locking behavior\" title=\"Direct link to The future Smart locking behavior\" translate=\"no\">​</a></h3><p>In the future we might also consider combining both modes, to get the best of both worlds.</p><p>Initial testing showed that with both modes, we had great success in handling the underlying issue. While we are not yet sure why this happens only on some systems when others work, we at least now have an option for users previously left out of using Jellyfin.</p><p>When I was researching this topic, I found many reports all over the internet facing the same error but nobody was able to provide a conclusive explanation whats really happening here.\nThere have been similar proposals made to handle it but there wasn't a \"ready to drop in\" solution that handles all the different cases or only code that required massive modifications to every EF Core query.\nJellyfin's implementation of the locking behaviors should be a copy-paste solution for everyone having the same issues as its using interceptors and the caller has no idea of the actual locking behavior.</p>","contentLength":7955,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=45781298"},{"title":"Myths Programmers Believe about CPU Caches (2018)","url":"https://software.rajivprab.com/2018/04/29/myths-programmers-believe-about-cpu-caches/","date":1761871616,"author":"whack","guid":186,"unread":true,"content":"<p><a href=\"https://en.wikipedia.org/wiki/Distributed_computing\" target=\"_blank\" rel=\"noopener\">distributed-system-architecture</a><a href=\"https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels\" target=\"_blank\" rel=\"noopener\">database-isolation-levels</a><a href=\"https://hackernoon.com/eventual-vs-strong-consistency-in-distributed-databases-282fdad37cf7\" target=\"_blank\" rel=\"noopener\">strong-vs-eventual consistency</a></p><p><a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html\" target=\"_blank\" rel=\"noopener\">volatiles</a><a href=\"http://tutorials.jenkov.com/java-concurrency/volatile.html\" target=\"_blank\" rel=\"noopener\">read/written all the way to main memory</a></p><p><a href=\"https://stackoverflow.com/questions/23593061/volatile-keyword-in-multicore-vs-single-processor\" target=\"_blank\" rel=\"noopener\">even single-core systems are at risk of concurrency bugs</a></p><h2></h2><p><a href=\"https://en.wikipedia.org/wiki/Consistency_model\" target=\"_blank\" rel=\"noopener\">great wealth of nuance</a></p><p><a rel=\"noopener\" href=\"http://tutorials.jenkov.com/java-concurrency/volatile.html\" target=\"_blank\">this tutorial</a></p><p><a rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/MESI_protocol\" target=\"_blank\">MESI protocol</a></p><ol><li><ol></ol></li><li><ol></ol></li><li><ol></ol></li><li><ol></ol></li></ol><ol><li><ol><li>The state of the cache-line is set to M, since it is now modified</li></ol></li></ol><h3></h3><ol><li><ol></ol></li><li><ol></ol></li></ol><ol></ol><h3></h3><ol><li><ol></ol></li></ol><h3></h3><ol></ol><h3></h3><ol></ol><p><a href=\"https://software.intel.com/en-us/articles/how-memory-is-accessed\" target=\"_blank\" rel=\"noopener\">multi-processor system</a></p><h2></h2><p><a rel=\"noopener\" href=\"https://stackoverflow.com/questions/4633866/is-volatile-expensive\" target=\"_blank\">immediately trigger cache reads/writes instead</a></p>","contentLength":371,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=45767178"}],"tags":["dev","hn"]}