{"id":"AXJnNj1p7gNGHeShbM5NH2qrEU51AXyHm","title":"Julia Evans","displayTitle":"Dev - Julia Evans","url":"https://jvns.ca/atom.xml","feedLink":"https://jvns.ca/atom.xml","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"Standards for ANSI escape codes","url":"https://jvns.ca/blog/2025/03/07/escape-code-standards/","date":1741305600,"author":"Julia Evans","guid":2,"unread":true,"content":"<p>Hello! Today I want to talk about ANSI escape codes.</p><p>For a long time I was vaguely aware of ANSI escape codes (“that’s how you make\ntext red in the terminal and stuff”) but I had no real understanding of where they were\nsupposed to be defined or whether or not there were standards for them. I just\nhad a kind of vague “there be dragons” feeling around them. While learning\nabout the terminal this year, I’ve learned that:</p><ol><li>ANSI escape codes are responsible for a lot of usability improvements\nin the terminal (did you know there’s a way to copy to your system clipboard\nwhen SSHed into a remote machine?? It’s an escape code called <a href=\"https://jvns.ca/til/vim-osc52/\">OSC 52</a>!)</li><li>They aren’t completely standardized, and because of that they don’t always\nwork reliably. And because they’re also invisible, it’s extremely\nfrustrating to troubleshoot escape code issues.</li></ol><p>So I wanted to put together a list for myself of some standards that exist\naround escape codes, because I want to know if they  to feel unreliable\nand frustrating, or if there’s a future where we could all rely on them with\nmore confidence.</p><p>Have you ever pressed the left arrow key in your terminal and seen ?\nThat’s an escape code! It’s called an “escape code” because the first character\nis the “escape” character, which is usually written as , , ,\n, or .</p><p>Escape codes are how your terminal emulator communicates various kinds of\ninformation (colours, mouse movement, etc) with programs running in the\nterminal. There are two kind of escape codes:</p><ol><li> which your terminal emulator sends for keypresses or mouse\nmovements that don’t fit into Unicode. For example “left arrow key” is\n, “Ctrl+left arrow” might be , and clicking the mouse might\nbe something like .</li><li> which programs can print out to colour text, move the\ncursor around, clear the screen, hide the cursor, copy text to the\nclipboard, enable mouse reporting, set the window title, etc.</li></ol><p>Now let’s talk about standards!</p><p>The first standard I found relating to escape codes was\n<a href=\"https://ecma-international.org/wp-content/uploads/ECMA-48_5th_edition_june_1991.pdf\">ECMA-48</a>,\nwhich was originally published in 1976.</p><ol><li>Define some general  for escape codes (like “CSI” codes, which are\n + something and “OSC” codes, which are  + something)</li><li>Define some specific escape codes, like how “move the cursor to the left” is\n, or “turn text red” is  . In the spec, the “cursor left”\none is called  and the one for changing colours is called\n.</li></ol><p>The formats are extensible, so there’s room for others to define more escape\ncodes in the future. Lots of escape codes that are popular today aren’t defined\nin ECMA-48: for example it’s pretty common for terminal applications (like vim,\nhtop, or tmux) to support using the mouse, but ECMA-48 doesn’t define escape\ncodes for the mouse.</p><p>There are a bunch of escape codes that aren’t defined in ECMA-48, for example:</p><ul><li>enabling mouse reporting (where did you click in your terminal?)</li><li>bracketed paste (did you paste that text or type it in?)</li><li>OSC 52 (which terminal applications can use to copy text to your system clipboard)</li></ul><p>I believe (correct me if I’m wrong!) that these and some others came from\nxterm, are documented in <a href=\"https://invisible-island.net/xterm/ctlseqs/ctlseqs.html\">XTerm Control Sequences</a>, and have\nbeen widely implemented by other terminal emulators.</p><p>This list of “what xterm supports” is not a standard exactly, but xterm is\nextremely influential and so it seems like an important document.</p><p>In the 80s (and to some extent today, but my understanding is that it was MUCH\nmore dramatic in the 80s) there was a huge amount of variation in what escape\ncodes terminals actually supported.</p><p>To deal with this, there’s a database of escape codes for various terminals\ncalled “terminfo”.</p><p>It looks like the standard for terminfo is called <a href=\"https://publications.opengroup.org/c243-1\">X/Open Curses</a>, though you need to create\nan account to view that standard for some reason. It defines the database format as well\nas a C library interface (“curses”) for accessing the database.</p><p>For example you can run this bash snippet to see every possible escape code for\n“clear screen” for all of the different terminals your system knows about:</p><pre><code>for term in $(toe -a | awk '{print $1}')\ndo\n  echo $term\n  infocmp -1 -T \"$term\" 2&gt;/dev/null | grep 'clear=' | sed 's/clear=//g;s/,//g'\ndone\n</code></pre><p>On my system (and probably every system I’ve ever used?), the terminfo database is managed by ncurses.</p><h3>should programs use terminfo?</h3><p>I think it’s interesting that there are two main approaches that applications\ntake to handling ANSI escape codes:</p><ol><li>Use the terminfo database to figure out which escape codes to use, depending\non what’s in the  environment variable. Fish does this, for example.</li><li>Identify a “single common set” of escape codes which works in “enough”\nterminal emulators and just hardcode those.</li></ol><p>Some examples of programs/libraries that take approach #2 (“don’t use terminfo”) include:</p><blockquote><p>[the terminfo authors] have done a lot of work that, at the time, was\nextremely important and helpful. My point is that it no longer is.</p></blockquote><p>I’m not going to do it justice so I’m not going to summarize it, I think it’s\nworth reading.</p><p>I was just talking about the idea that you can use a “common set” of escape\ncodes that will work for most people. But what is that set? Is there any agreement?</p><p>I really do not know the answer to this at all, but from doing some reading it\nseems like it’s some combination of:</p><ul><li>The codes that the VT100 supported (though some aren’t relevant on modern terminals)</li><li>what’s in ECMA-48 (which I think also has some things that are no longer relevant)</li><li>What xterm supports (though I’d guess that not everything in there is actually widely supported enough)</li></ul><p>and maybe ultimately “identify the terminal emulators you think your users are\ngoing to use most frequently and test in those”, the same way web developers do\nwhen deciding which CSS features are okay to use</p><p>I don’t think there are any resources like <a href=\"https://caniuse.com/\">Can I use…?</a> or\n<a href=\"https://web-platform-dx.github.io/web-features/\">Baseline</a> for the terminal\nthough. (in theory terminfo is supposed to be the “caniuse” for the terminal\nbut it seems like it often takes 10+ years to add new terminal features when\npeople invent them which makes it very limited)</p><h3>some reasons to use terminfo</h3><p>I also asked on Mastodon why people found terminfo valuable in 2025 and got a\nfew reasons that made sense to me:</p><ul><li>some people expect to be able to use the  environment variable to\ncontrol how programs behave (for example with ), and there’s\nno standard for how that should work in a post-terminfo world</li><li>even though there’s  variation between terminal emulators than\nthere was in the 80s, there’s far from zero variation: there are graphical\nterminals, the Linux framebuffer console, the situation you’re in when\nconnecting to a server via its serial console, Emacs shell mode, and probably\nmore that I’m missing</li><li>there is no one standard for what the “single common set” of escape codes\nis, and sometimes programs use escape codes which aren’t actually widely\nsupported enough</li></ul><h3>terminfo &amp; user agent detection</h3><p>The way that ncurses uses the  environment variable to decide which\nescape codes to use reminds me of how webservers used to sometimes use the\nbrowser user agent to decide which version of a website to serve.</p><p>It also seems like it’s had some of the same results – the way iTerm2 reports\nitself as being “xterm-256color” feels similar to how Safari’s user agent is\n“Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_4) AppleWebKit/605.1.15 (KHTML,\nlike Gecko) Version/18.3 Safari/605.1.15”. In both cases the terminal emulator\n/ browser ends up changing its user agent to get around user agent detection\nthat isn’t working well.</p><p>On the web we ended up deciding that user agent detection was not a good\npractice and to instead focus on standardization so we can serve the same\nHTML/CSS to all browsers. I don’t know if the same approach is the future in\nthe terminal though – I think the terminal landscape today is much more\nfragmented than the web ever was as well as being much less well funded.</p><h3>some more documents/standards</h3><p>A few more documents and standards related to escape codes, in no particular order:</p><h3>why I think this is interesting</h3><p>I sometimes see people saying that the unix terminal is “outdated”, and since I\nlove the terminal so much I’m always curious about what incremental changes\nmight make it feel less “outdated”.</p><p>Maybe if we had a clearer standards landscape (like we do on the web!) it would\nbe easier for terminal emulator developers to build new features and for\nauthors of terminal applications to more confidently adopt those features so\nthat we can all benefit from them and have a richer experience in the terminal.</p><p>Obviously standardizing ANSI escape codes is not easy (ECMA-48 was first\npublished almost 50 years ago and we’re still not there!). I don’t even know\nwhat all of the challenges are. But the situation with HTML/CSS/JS used to be\nextremely bad too and now it’s MUCH better, so maybe there’s hope.</p>","contentLength":8892,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How to add a directory to your PATH","url":"https://jvns.ca/blog/2025/02/13/how-to-add-a-directory-to-your-path/","date":1739449676,"author":"Julia Evans","guid":1,"unread":true,"content":"<p>I was talking to a friend about how to add a directory to your PATH today. It’s\nsomething that feels “obvious” to me since I’ve been using the terminal for a\nlong time, but when I searched for instructions for how to do it, I actually\ncouldn’t find something that explained all of the steps – a lot of them just\nsaid “add this to ”, but what if you’re not using bash? What if your\nbash config is actually in a different file? And how are you supposed to figure\nout which directory to add anyway?</p><p>So I wanted to try to write down some more complete directions and mention some\nof the gotchas I’ve run into over the years.</p><p>Here’s a table of contents:</p><h3>step 1: what shell are you using?</h3><p>If you’re not sure what shell you’re using, here’s a way to find out. Run this:</p><ul><li>if you’re using , it’ll print out </li><li>if you’re using , it’ll print out </li><li>if you’re using , it’ll print out an error like “In fish, please use\n$fish_pid” ( isn’t valid syntax in fish, but in any case the error\nmessage tells you that you’re using fish, which you probably already knew)</li></ul><p>Also bash is the default on Linux and zsh is the default on Mac OS (as of\n2024). I’ll only cover bash, zsh, and fish in these directions.</p><h3>step 2: find your shell’s config file</h3><ul><li>in zsh, it’s probably </li><li>in bash, it might be , but it’s complicated, see the note in the next section</li><li>in fish, it’s probably <code>~/.config/fish/config.fish</code> (you can run  if you want to be 100% sure)</li></ul><h3>a note on bash’s config file</h3><p>Bash has three possible config files: , , and .</p><p>If you’re not sure which one your system is set up to use, I’d recommend\ntesting this way:</p><ol><li>add  to your </li><li>If you see “hi there”, that means  is being used! Hooray!</li><li>Otherwise remove it and try the same thing with </li><li>You can also try  if the first two options don’t work.</li></ol><p>(there are a lot of <a href=\"https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html\">elaborate flow charts</a> out there that explain how bash\ndecides which config file to use but IMO it’s not worth it to internalize them\nand just testing is the fastest way to be sure)</p><h3>step 3: figure out which directory to add</h3><p>Let’s say that you’re trying to install and run a program called \nand it doesn’t work, like this:</p><pre><code>$ npm install -g http-server\n$ http-server\nbash: http-server: command not found\n</code></pre><p>How do you find what directory  is in? Honestly in general this is\nnot that easy – often the answer is something like “it depends on how npm is\nconfigured”. A few ideas:</p><ul><li>Often when setting up a new installer (like , , , etc),\nwhen you first set it up it’ll print out some directions about how to update\nyour PATH. So if you’re paying attention you can get the directions then.</li><li>Sometimes installers will automatically update your shell’s config file\nto update your  for you</li><li>Sometimes just Googling “where does npm install things?” will turn up the\nanswer</li><li>Some tools have a subcommand that tells you where they’re configured to\ninstall things, like:\n<ul><li>Node/npm:  (then append )</li><li>Go:  (then append )</li><li>asdf: <code>asdf info | grep ASDF_DIR</code> (then append  and )</li></ul></li></ul><h3>step 3.1: double check it’s the right directory</h3><p>Once you’ve found a directory you think might be the right one, make sure it’s\nactually correct! For example, I found out that on my machine,  is\nin . I can make sure that it’s the right directory by trying to\nrun the program  in that directory like this:</p><pre><code>$ ~/.npm-global/bin/http-server\nStarting up http-server, serving ./public\n</code></pre><p>It worked! Now that you know what directory you need to add to your ,\nlet’s move to the next step!</p><h3>step 4: edit your shell config</h3><p>Now we have the 2 critical pieces of information we need:</p><ol><li>Which directory you’re trying to add to your PATH (like  )</li><li>Where your shell’s config is (like , , or <code>~/.config/fish/config.fish</code>)</li></ol><p>Now what you need to add depends on your shell:</p><p>Open your shell’s config file, and add a line like this:</p><pre><code>export PATH=$PATH:~/.npm-global/bin/\n</code></pre><p>(obviously replace  with the actual directory you’re trying to add)</p><p>You can do the same thing as in bash, but zsh also has some slightly fancier\nsyntax you can use if you prefer:</p><pre><code>path=(\n  $path\n  ~/.npm-global/bin\n)\n</code></pre><p>In fish, the syntax is different:</p><pre><code>set PATH $PATH ~/.npm-global/bin\n</code></pre><p>(in fish you can also use , some notes on that <a href=\"https://jvns.ca/blog/2025/02/13/how-to-add-a-directory-to-your-path/#a-note-on-fish-add-path\">further down</a>)</p><h3>step 5: restart your shell</h3><p>Now, an extremely important step: updating your shell’s config won’t take\neffect if you don’t restart it!</p><ol><li>open a new terminal (or terminal tab), and maybe close the old one so you don’t get confused</li><li>Run  to start a new shell (or  if you’re using zsh, or  if you’re using fish)</li></ol><p>I’ve found that both of these usually work fine.</p><p>And you should be done! Try running the program you were trying to run and\nhopefully it works now.</p><p>If not, here are a couple of problems that you might run into:</p><h3>problem 1: it ran the wrong program</h3><p>If the wrong  of a program is running, you might need to add the\ndirectory to the  of your PATH instead of the end.</p><p>For example, on my system I have two versions of  installed, which I\ncan see by running :</p><pre><code>$ which -a python3\n/usr/bin/python3\n/opt/homebrew/bin/python3\n</code></pre><p>The one your shell will use is the .</p><p>If you want to use the Homebrew version, you need to add that directory\n() to the  of your PATH instead, by putting this in\nyour shell’s config file (it’s  instead of the usual )</p><pre><code>export PATH=/opt/homebrew/bin/:$PATH\n</code></pre><pre><code>set PATH ~/.cargo/bin $PATH\n</code></pre><h3>problem 2: the program isn’t being run from your shell</h3><p>All of these directions only work if you’re running the program . If you’re running the program from an IDE, from a GUI, in a cron job,\nor some other way, you’ll need to add the directory to your PATH in a different\nway, and the exact details might depend on the situation.</p><ul><li>use the full path to the program you’re running, like <code>/home/bork/bin/my-program</code></li><li>put the full PATH you want as the first line of your crontab (something like\nPATH=/bin:/usr/bin:/usr/local/bin:….). You can get the full PATH you’re\nusing in your shell by running .</li></ul><p>I’m honestly not sure how to handle it in an IDE/GUI because I haven’t run into\nthat in a long time, will add directions here if someone points me in the right\ndirection.</p><h3>problem 3: duplicate  entries making it harder to debug</h3><p>If you edit your path and start a new shell by running  (or , or\n), you’ll often end up with duplicate  entries, because the shell\nkeeps adding new things to your  every time you start your shell.</p><p>Personally I don’t think I’ve run into a situation where this kind of\nduplication breaks anything, but the duplicates can make it harder to debug\nwhat’s going on with your  if you’re trying to understand its contents.</p><p>Some ways you could deal with this:</p><ol><li>If you’re debugging your , open a new terminal to do it in so you get\na “fresh” state. This should avoid the duplication.</li><li>Deduplicate your  at the end of your shell’s config  (for example in\nzsh apparently you can do this with )</li><li>Check that the directory isn’t already in your  when adding it (for\nexample in fish I believe you can do this with <code>fish_add_path --path /some/directory</code>)</li></ol><p>How to deduplicate your  is shell-specific and there isn’t always a\nbuilt in way to do it so you’ll need to look up how to accomplish it in your\nshell.</p><h3>problem 4: losing your history after updating your </h3><p>Here’s a situation that’s easy to get into in bash or zsh:</p><ol><li>Run  to reload your config</li><li>Press the up arrow a couple of times to rerun the failed command (or open a new terminal)</li><li>The failed command isn’t in your history! Why not?</li></ol><p>This happens because in bash, by default, history is not saved until you exit\nthe shell.</p><p>Some options for fixing this:</p><ul><li>Instead of running  to reload your config, run  (or\n in zsh). This will reload the config inside your current\nsession.</li><li>Configure your shell to continuously save your history instead of only saving\nthe history when the shell exits. (How to do this depends on whether you’re\nusing bash or zsh, the history options in zsh are a bit complicated and I’m\nnot exactly sure what the best way is)</li></ul><p>When you install  (Rust’s installer) for the first time, it gives you\nthese instructions for how to set up your PATH, which don’t mention a specific\ndirectory at all.</p><pre><code>This is usually done by running one of the following (note the leading DOT):\n\n. \"$HOME/.cargo/env\"        \t# For sh/bash/zsh/ash/dash/pdksh\nsource \"$HOME/.cargo/env.fish\"  # For fish\n</code></pre><p>The idea is that you add that line to your shell’s config, and their script\nautomatically sets up your  (and potentially other things) for you.</p><p>This is pretty common (for example <a href=\"https://github.com/Homebrew/install/blob/deacfa6a6e62e5f4002baf9e1fac7a96e9aa5d41/install.sh#L1072-L1087\">Homebrew</a> suggests you eval ), and there are\ntwo ways to approach this:</p><ol><li>Just do what the tool suggests (like adding  to your shell’s config)</li><li>Figure out which directories the script they’re telling you to run would add\nto your PATH, and then add those manually. Here’s how I’d do that:\n<ul><li>Run  in my shell (or the fish version if using fish)</li><li>Run <code>echo \"$PATH\" | tr ':' '\\n' | grep cargo</code> to figure out which directories it added</li><li>See that it says  and shorten that to </li><li>Add the directory  to PATH (with the directions in this post)</li></ul></li></ol><p>I don’t think there’s anything wrong with doing what the tool suggests (it\nmight be the “best way”!), but personally I usually use the second approach\nbecause I prefer knowing exactly what configuration I’m changing.</p><p>fish has a handy function called  that you can run to add a directory to your  like this:</p><pre><code>fish_add_path /some/directory\n</code></pre><p>This is cool (it’s such a simple command!) but I’ve stopped using it for a couple of reasons:</p><ol><li>Sometimes  will update the  for every session in the\nfuture (with a “universal variable”) and sometimes it will update the \njust for the current session and it’s hard for me to tell which one it will\ndo. In theory the docs explain this but I could not understand them.</li></ol><p>Hopefully this will help some people. Let me know (on Mastodon or Bluesky) if\nyou there are other major gotchas that have tripped you up when adding a\ndirectory to your PATH, or if you have questions about this post!</p>","contentLength":9892,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}