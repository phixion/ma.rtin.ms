{"id":"2bP4pJr4wVimh6yine63HqNeafoyheTFz1gqCrQ4h7Z","title":"AlgoMaster Newsletter","displayTitle":"Dev - Algomaster","url":"https://blog.algomaster.io/feed","feedLink":"https://blog.algomaster.io/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"Top 6 API Architecture Styles","url":"https://blog.algomaster.io/p/top-6-api-architecture-styles","date":1761796357,"author":"Ashish Pratap Singh","guid":703,"unread":true,"content":"<p>An <strong>API (Application Programming Interface)</strong> defines how two systems communicate, what data can be shared, and in what format.</p><p>But not all APIs are built the same. Over time, as applications evolved, so did the challenges they faced.</p><p>This led to the creation of new API styles, each designed to solve specific problems related to <strong>performance, flexibility, or real-time updates</strong>.</p><p>In this article, we’ll break down the  that power modern software.</p><p>In the beginning, there was <strong>SOAP (Simple Object Access Protocol)</strong>.</p><p>As the internet began to rise in the late 1990s, companies needed a standardized way for applications to communicate across different platforms and programming languages.</p><p>SOAP emerged as the first major standard to solve this.</p><p>SOAP demands that all messages be in  format, and it operates based on a very strict contract called a <strong>WSDL (Web Services Description Language)</strong>.</p><p>Think of WSDL as a detailed instruction manual that precisely defines every operation you can perform.</p><p>SOAP is very “verbose,” meaning it uses a lot of text to describe a simple action. All that text for one simple request makes messages large, which  network transmission and processing.</p><p>Furthermore, the strict WSDL contract creates ; if the server changes any part of the contract, the client will often break.</p><p>While this was acceptable for large, internal enterprise systems, SOAP was just too heavy and inflexible for the fast moving web and new mobile apps. Developers needed something simpler, lighter, and more flexible that used the web’s own language, HTTP.</p><p>In response to SOAP’s complexity, <strong>REST (Representational State Transfer)</strong> emerged and it quickly became the standard for the modern web.</p><p>REST represented a complete mindset shift. Instead of complex operations defined in a WSDL, REST treats data as “resources” (like ) that you interact with using the standard HTTP methods (GET, POST, PUT, DELETE) that power the entire web.</p><p>It is , meaning every request contains all the information needed to process it. It also embraced  over XML, which is far lighter and easier for both humans and machines (especially JavaScript) to read.</p><p>REST is amazing and runs the majority of the web. But as applications grew, two common problems emerged:</p><ol><li><p> Clients often receive more data than they need. You just need a user’s name, but  returns their name, address, entire post history, and a dozen other fields. This is wasted data that slows down apps, especially on mobile networks.</p></li><li><p> You need to show a user’s profile  their latest posts. This requires two separate requests:  and then . This “waterfall” of requests creates noticeable lag.</p></li></ol><p>As frontend applications grew richer especially with mobile and single-page apps, developers wanted more control over the data they fetched.</p><p>This led to the rise of .</p><p>What if you could ask for  what you need, all in one trip? </p><p>That’s what Facebook set out to solve when they created in 2012 and open-sourced in 2015.</p><p>GraphQL is a <strong>query language for your API</strong>. The most important shift is that the , not the server, defines the shape of the data it needs. </p><p>Instead of dozens of REST endpoints, you typically have just one (like ) that accepts a query. The client sends a query that precisely describes the data it wants, and the server returns a JSON object in that exact same shape.</p><p>This single query can pull from multiple sources (like a user database and a post database) and return it all in one response.</p><p>There is no  (you only get the  and , not the user’s email or post bodies) and no  (you get the user and their posts in one round trip).</p><p>However, GraphQL introduces its own set of challenges:</p><ul><li><p><strong>Complex Server Implementation:</strong> Building a GraphQL server (especially with nested data) can be more complex than a simple REST API.</p></li><li><p> The single endpoint and dynamic queries make traditional HTTP caching mechanisms less effective compared to REST.</p></li></ul><p>GraphQL shares a fundamental trait with REST: it’s text based (JSON) and works on a client “pull” model, where the client must make a request.</p><p>For high-performance internal communication between dozens of microservices, the overhead of parsing text and the HTTP request-response pattern is too slow.</p><p>This need for raw speed led to .</p><p>Developed by Google and open-sourced in 2015, gRPC is a modern <strong>Remote Procedure Call (RPC)</strong> framework designed for high-performance, language-agnostic communication  services.</p><p>It’s built for performance in two key ways:</p><ol><li><p> It replaces text-based JSON with <strong>Protocol Buffers (Protobufs)</strong>, a highly efficient binary format. This is much faster for computers to  (write) and  (read).</p></li><li><p> It runs on  by default. This modern protocol is far more efficient than HTTP/1.1, supporting features like , where many requests can fly back and forth on a single connection.</p></li></ol><p>You define your services and messages in a simple  file. This file acts as a language-agnostic contract, which gRPC uses to generate native code for any language you need (Java, Go, Python, etc.).</p><p>gRPC is an excellent choice for <strong>internal Service-to-Service Communication</strong>, especially over low-bandwidth networks.</p><p>However, its binary format is not human-readable, which can make debugging more challenging. It also isn’t directly supported by browsers, requiring a proxy like gRPC-Web for client-side use.</p><p>Although highly performant, gRPC is still a request-response pattern: the client asks, the server answers.</p><p>What if you need a persistent, two-way connection for a live chat app, a stock ticker, or a multiplayer game?</p><p>That’s where  comes in.</p><p>Traditional HTTP, which underpins REST, GraphQL, and gRPC, is a  protocol. The client must always initiate the conversation.</p><p>This becomes inefficient for real-time use cases, because the only way to constantly get updates is to repeatedly ask the server () or keep a request hanging until something happens ().</p><p> was built to solve exactly this. It creates a ,  communication channel over a single connection.</p><p>The connection begins as a normal HTTP request, then upgrades to a WebSocket. After that, both client and server can send data to each other whenever they want without new requests.</p><p><strong>Client-side code example:</strong></p><p>This model is perfect for live dashboards, multiplayer gaming, or chat applications where the server must push updates instantly.</p><p>But running WebSockets at scale is not trivial. You have to manage millions of long-lived connections, ensure state consistency across servers, and handle reconnects and failures.</p><p>Another limitation: the client must initiate the connection first. That works for browsers and apps, but fails for server-to-server events.</p><p>For example, what if Stripe’s server needs to notify  server that a payment just succeeded? Your server isn’t sitting there with an open connection to Stripe.</p><p>In such cases, we need a different mechanism:  a .</p><p>Webhooks are essentially “reverse APIs.” Instead of your application polling an API endpoint for new data, the  calls  (acting as the client) when a specific event occurs. It’s a user-defined HTTP callback.</p><p>A Webhook is a server to server push model. You provide a URL (an endpoint on your server) to a third party service like GitHub, Stripe, or Slack. When a specific event happens (like a  or a ), that service instantly sends an HTTP POST request with the event data (the payload) to your URL.</p><p>Webhooks eliminate the need for constant polling, allowing systems to react to events asynchronously and saving resources for both the client and the server.</p><p>Despite their power, Webhooks require careful implementation:</p><ul><li><p> Your endpoint is public. You  verify a signature (like ) to ensure the request is legitimate and not a forgery.</p></li><li><p> Webhooks can fail and be retried. Your endpoint must be , meaning processing the same notification multiple times has the same effect as processing it once.</p></li></ul><p>As you can see, there is no single “best” API. The “best” API is the one that fits your use case. In fact, a single, complex application will often use many of them together:</p><ul><li><p> or  for its public web and mobile apps.</p></li><li><p> for its internal, high speed microservice communication.</p></li><li><p> for its real time chat feature.</p></li><li><p> to receive events from its payment provider.</p></li></ul><p>The journey from SOAP to Webhooks shows an evolution towards more specific, efficient, and flexible tools. The real skill is not knowing just one, but knowing which one to pick for the job.</p><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/scalability?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQwMDc4MDk0LCJpYXQiOjE3Mzc1MzgxODMsImV4cCI6MTc0MDEzMDE4MywiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.xroFXQDDEPvo2FWnnt-G2Ji9MzYIDtJ68NRQX6sT8x8&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p> If you’re enjoying this newsletter and want to get even more value, consider becoming a .</p><p>I hope you have a lovely day!</p>","contentLength":8616,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/$s_!VOZJ!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F230bee2c-6957-499a-8bda-473bfb05b4b2_2332x1352.png","enclosureMime":"","commentsUrl":null},{"title":"How to Securely Store Passwords in a Database","url":"https://blog.algomaster.io/p/securely-storing-passwords-in-a-database","date":1761624071,"author":"Ashish Pratap Singh","guid":702,"unread":true,"content":"<p>A password is meant to be . If someone steals it, they do not just break into one account, they often get access to every other place where the user reused that same password.</p><p>That is why  is not optional. It is our responsibility as developers to store passwords in a form that remains safe <strong>even if the database is stolen</strong>.</p><p>In this article, we will break down  from first principles. We will begin with , then climb upward to the correct techniques and the reasoning behind them.</p><h2>1. Storing in Plain Text: The Worst Way</h2><p>The absolute worst thing you can do is store a password as plain text. This means if a user signs up with the password “Pa$$w0rd123”, your database stores the literal string “Pa$$w0rd123”.</p><ul><li><p> An attacker who finds an SQL injection vulnerability can dump your entire  table in one query. There is nothing to decode or crack. They instantly have the passwords to every user’s account.</p><pre><code>SELECT email, password FROM users;</code></pre></li><li><p> A developer, DBA, support engineer or cloud vendor with read access can export the entire password list in seconds, and you would never know it happened. Many breaches are not hackers, they are insiders.</p></li></ul><p>With plain text, there is no second line of protection. You cannot “undo” the exposure. Once seen, it is gone forever.</p><p>Now that we have established the worst practice, let us examine the first step in doing better: .</p><h2>2. Simple Hashing: Slightly Better But Still Broken</h2><p>A  is supposed to be a one-way transformation.</p><p>Think of it like a blender. You can drop a banana and strawberry in, blend them, and get a smoothie. You can recognize the smoothie as “fruit mix” but you can never reverse it back into the original fruits.</p><p>That is the idea behind a hash. You feed in a password and get a fixed-length output that cannot be reversed.</p><p>Early systems used fast general-purpose hash algorithms like  and  for this.</p><p>You would run “Pa$$w0rd123” through MD5 and get a hash like:</p><pre><code>e10adc3949ba59abbe56e057f20f883e </code></pre><p>It looks random and irreversible. It looks safe. Sounds good, right?</p><p>Here is the twist — it is not.</p><h3>Why fast hashing ruins security</h3><p>Algorithms like MD5, SHA-1, and even SHA-256 are designed to be extremely fast. That is great for file integrity and signatures, but disastrous for passwords. </p><p>Modern GPUs can compute <strong>billions of these hashes per second</strong>, which means an attacker can brute-force weak passwords almost instantly.</p><p>Worse, attackers do not even have to brute-force from scratch. They can use something called .</p><p>Rainbow Tables are massive precomputed dictionaries where attackers hash millions of common passwords in advance and store the mapping. A lookup is enough to reveal the plaintext password.</p><p>For MD5, a tiny fragment of a rainbow table might look like:</p><ol><li><p> The attacker steals your  table and finds a list of password hashes.</p></li><li><p> They see the hash <code>5f4dcc3b5aa765d61d8327deb882cf99</code> for a user.</p></li><li><p> Instead of trying to “guess” the password, they just look up this hash in their giant rainbow table.</p></li><li><p> They instantly find the matching plaintext password: “password”.</p></li></ol><p>No brute force. No guessing. Just a dictionary lookup.</p><p>This method works because old, fast hashing functions (like MD5 or SHA-1) always produce the same exact hash for the same exact input.</p><p>This is why “simple hashing” is still insecure. The fix is not just “hash it”, it is “hash it the right way.”</p><h2>3. The Right Kind of HASH</h2><p>A secure password hashing function must be , , and <strong>computationally expensive</strong> on purpose.</p><p>The idea is simple: if every password attempt takes real time and real resources, large-scale cracking becomes impractical even with modern GPUs.</p><h3>Why slow hashing kills rainbow tables</h3><p>Rainbow tables only work when hashing is fast and deterministic. Slow and adaptive hash functions make precomputation economically pointless.</p><p>To generate a rainbow table now, an attacker would have to spend years and extreme hardware cost just to compute the table before even attacking.</p><h3>Popular Slow Hashing Options</h3><p>Here are the three widely used hashing options:</p><p>This has been the industry standard for a long time. Its key feature is a configurable . You can tell it “make this hash take 100 milliseconds.” As computers get faster in the future, you can just increase the cost factor to keep it slow.</p><p>This was designed to be “memory hard.” It forces the hashing process to consume significant RAM, which makes pre-computation and GPU attacks extremely inefficient. GPUs excel at raw compute but struggle when memory is the bottleneck.</p><p>This is the modern preferred option. It won the official Password Hashing Competition in 2015. It is resistant to GPU attacks, highly configurable (you can balance its memory, CPU, and parallelism needs), and is the top recommendation by OWASP (Open Web Application Security Project).</p><p> Use  if your language and framework support it. If not,  is an extremely solid and widely supported alternative.</p><p>Slow hashing removes the attacker’s “shortcut”.</p><p>But slow hashing by itself still has a weakness. The same password still produces the same hash. This is where  enters the picture.</p><p>A “salt” is simply a <strong>unique, random string generated for each user</strong>.</p><p>Returning to the smoothie analogy: a salt is like adding a different mystery ingredient to every person’s blend before mixing. Even if two people start with the same fruits (same password), the final smoothie looks completely different.</p><p>You do not hash the raw password. You hash: </p><p>Two users with the same password now produce completely different hashes.</p><pre><code>Alice password = “123456”\nAlice salt     = “abc_salt”\nStored hash    = H(”123456abc_salt”)\n\nBob password   = “123456”\nBob salt       = “xyz_salt”\nStored hash    = H(”123456xyz_salt”)</code></pre><p>The salt must be ,  (at least 16 bytes), and .</p><p>You must  use usernames, timestamps, or predictable data. Use a cryptographically secure random generator, for example:</p><ul><li><p> in Node</p></li></ul><h3>Why salting kills rainbow tables</h3><p>Rainbow tables depend on the assumption that the same password always leads to the same hash. Salting breaks that. Now the attacker would need a separate precomputed table for , which is mathematically and economically infeasible.</p><p>The salt is . You store it right next to the hash. You need it later to re-compute the hash during login.</p><blockquote><p> In many modern implementations (bcrypt, Argon2, PBKDF2), the salt is automatically generated and embedded inside the final hash output itself so you never handle salts manually.</p></blockquote><p>So far we have made two things clear:</p><ol><li><p>Hashing must be slow and adaptive</p></li><li><p>Hashes must be salted to prevent precomputation and duplicate patterns</p></li></ol><p>Those two alone already raise the bar enormously. But there is still one more defensive layer that can make a breach dramatically less useful to an attacker even if they steal both the hashes and the salts.</p><p>That additional layer is called .</p><p>Peppering adds one more defensive layer by mixing in a secret value that is <strong>never stored in the database</strong>. Even if an attacker steals your user table (hashes and salts), they still cannot verify guesses without the pepper.</p><p>A  is a random secret value (for example 32 bytes) that is combined with the password and salt before hashing. It does not replace salts or slow hashing. It complements them.</p><p>If salt is a per-user ingredient added to each smoothie, the pepper is the restaurant’s master secret sauce stored in a separate locked kitchen. The smoothies can be stolen. The recipe cannot.</p><h3>Where is the pepper stored?</h3><p>Unlike salts, peppers <strong>must be treated as secrets</strong> and kept outside the database.</p><p>Typical storage locations:</p><ul><li><p>A secure environment variable (e.g., )</p></li><li><p>A secrets management system (like HashiCorp Vault, AWS Secrets Manager, or Google Secret Manager).</p></li></ul><p>Peppers should never sit in the same system that holds the hashes.</p><h3>Two common pepper patterns</h3><ol><li><p>One secret value used for the whole application. Simple to implement. Must be carefully protected.</p></li><li><p><strong>Per-user pepper stored externally: </strong>A different secret per user kept in a separate secure store (HSM or encrypted key-value store). Harder to manage but limits blast radius if one pepper is leaked.</p></li></ol><p>A typical pipeline with salt and pepper:</p><p>Imagine an attacker steals your . They have all the usernames, all the hashes, and all the salts.</p><p>Without pepper, they can immediately begin brute-forcing, because they know the hashing function and inputs except the password. With pepper, they are missing a required input.</p><p>They are trying to solve:</p><pre><code>hash(password + salt)   ❌   (what attacker assumes)</code></pre><p>But the real stored hash came from:</p><pre><code>hash(password + salt + pepper)   ✅</code></pre><h2>6. Putting It All Together</h2><p>Let’s see how these pieces fit in a real application.</p><ol><li><p>A user signs up with their password (e.g., “Pa$$w0rd123”).</p></li><li><p>Your server generates a cryptographically secure .</p></li><li><p>Your server retrieves the application’s secret  from environment variable.</p></li><li><p>Your server uses a library (like  or ) to hash the password.</p></li><li><p>The library combines the <code>(password + salt + pepper)</code> and runs them through the slow hash algorithm.</p></li><li><p>The server stores the  and  in the  table. The pepper is never stored.</p></li></ol><ol><li><p>A user tries to log in with their email and password (e.g., “Pa$$w0rd123”).</p></li><li><p>The server retrieves the user’s  and  from the database (using their email).</p></li><li><p>The server retrieves the application’s secret  from the environment variable.</p></li><li><p>The server combines the  with the  and .</p></li><li><p>The server hands this combined string  the  to the  (or equivalent) function.</p></li><li><p>The library function re-hashes the user’s input using that same salt, and securely compares the two.</p></li><li><p>If they match, the user is authenticated. If not, the password was wrong.</p></li></ol><h3>Practical Code Example (Node.js)</h3><p>Here is a clean and minimal example using  in Node.js where the library handles salt generation for you.</p><h2>7. The “Best” Way? Don’t Store Passwords at All.</h2><p>There is one more option. Do not keep passwords. Delegate authentication to a trusted identity provider instead.</p><p>You have seen this everywhere: “Sign in with Google,” “Sign in with Facebook,” or “Sign in with GitHub.”</p><p>Under the hood these flows use standards like OAuth 2.0 and OpenID Connect.</p><ul><li><p> You never store or manage user passwords. You shift the entire security burden to experts at Google, Microsoft, or Apple. A breach of your database is less catastrophic because you do not have any passwords to steal.</p></li><li><p> You create a dependency on a third party. If Google’s login service is down, your users cannot log in. It also may not be suitable for all types of applications.</p></li></ul><blockquote><p>While building authentication at , I chose OAuth (Google and GitHub login) to avoid the complexity and risk of password management. For users who did not use Google accounts (e.g., Outlook or Hotmail), I added email OTP-based authentication as a fallback instead of storing passwords.</p></blockquote><p>Protecting user passwords is a fundamental responsibility for anyone building software. When you do it correctly, your users stay safe and your product earns trust. When you get it wrong, the fallout can be immediate, public, and irreversible.</p><p>Here are the non-negotiable rules:</p><ul><li><p> store passwords in plain text.</p></li><li><p> use old, fast hashes like MD5 or SHA-1.</p></li><li><p> use a modern, slow, adaptive hash (like  or ).</p></li><li><p> use a unique  for every single user (which modern libraries do for you).</p></li><li><p> using a secret  (stored outside the DB) to protect against database theft.</p></li><li><p>, use a trusted third party provider (like “Sign in with Google”) and do not handle passwords at all.</p></li></ul><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/scalability?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQwMDc4MDk0LCJpYXQiOjE3Mzc1MzgxODMsImV4cCI6MTc0MDEzMDE4MywiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.xroFXQDDEPvo2FWnnt-G2Ji9MzYIDtJ68NRQX6sT8x8&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p> If you’re enjoying this newsletter and want to get even more value, consider becoming a .</p><p>I hope you have a lovely day!</p>","contentLength":11627,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/$s_!XCWf!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ea8f9a6-9de3-4221-810e-636a6f4fb034_1908x1336.png","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}