{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Implementing Cross-Site Request Forgery (CSRF) Protection in Go Web Applications","url":"https://themsaid.com/csrf-protection-go-web-applications","date":1741784350,"author":"/u/themsaid","guid":332,"unread":true,"content":"<p>In a <a href=\"https://themsaid.com/building-secure-session-manager-in-go\" rel=\"nofollow\">previous article</a>, we discussed web sessions and explained how a session is created when a visitor first browses our web application. This session is then stored in a browser cookie and sent on every subsequent request, allowing the server to identify the visitor.</p><p>Now, imagine you are logged into GitHub and there's a session cookie in your browser that's sent with every request to GitHub. What would happen if you visit a website that has this hidden form?</p><div><pre>=\"\" =\"\"=\"\" =\"\" =\"\"=\"\" =\"\" =\"\"</pre></div><p>The JavaScript code here submits a form that sends a POST request to the  endpoint with two hidden fields:  and . When the form is submitted, the browser detects an existing cookie for the  domain and includes it in the request. This triggers a transfer operation, moving one of your repositories to the attacker's account.</p><p>This type of attack is known as Cross-Site Request Forgery (CSRF or XSRF for short), and it can take many forms beyond the example described above. In general, a CSRF attack occurs when an attacker tricks a user into making an unintended request to a trusted website where they are already authenticated. Because the user's session cookie is automatically included in the request, the website processes it as if it were a legitimate action initiated by the user.</p><div><h2>Secure Cookies Alone Can't Stop CSRF Attacks</h2><a aria-label=\"Permalink: Secure Cookies Alone Can't Stop CSRF Attacks\" href=\"https://themsaid.com/csrf-protection-go-web-applications#secure-cookies-alone-cant-stop-csrf-attacks\"></a></div><p>A secure cookie is one that has the following attributes:</p><div><pre>http.{\n\t: ,\n\t:   ,\n\t: .,\n}</pre></div><p>Setting  prevents JavaScript from accessing the cookie,  ensures it is only sent over HTTPS, and <code>SameSite: http.SameSiteLaxMode</code> restricts cross-site cookie transmission.</p><p>You might assume that setting the  cookie attribute is sufficient to prevent cross-site requests. However, this is not always the case. Older browser versions do not consistently enforce this attribute, leaving them vulnerable to Cross-Site Request Forgery attacks. Additionally, clickjacking presents another risk. In this type of attack, an attacker embeds your application inside an invisible iframe and tricks users into clicking buttons or performing actions they didnâ€™t intend. Since these interactions originate from the same domain, they bypass SameSite restrictions, allowing the attacker to execute unauthorized actions on behalf of the user.</p><blockquote><p>Lax enforcement provides reasonable defense in depth against CSRF attacks that rely on unsafe HTTP methods (like POST), but does not offer a robust defense against CSRF as a general category of attack. When possible, developers should use a session management mechanism to mitigate the risk of CSRF more completely.</p></blockquote><p>This emphasizes that while  provides some protection against CSRF attacks, it is not a complete solution. To fully mitigate the risk of CSRF, we should implement additional session management techniques, with the most common being the use of CSRF tokens.</p><p>The concept behind CSRF tokens is to establish a shared secret token between the client and the server. When a user first starts a session, the server generates a unique CSRF token and stores it alongside the session data. The server then sends this token to the client in the response. Each time the client makes a POST, PUT, DELETE, or PATCH request, it must include the CSRF token, typically within the body of the request or in a custom header, which the server verifies by comparing it to the one stored in the token.</p><p>Now, consider the CSRF attack example we shared earlier:</p><div><pre>=\"\" =\"\"=\"\" =\"\" =\"\"=\"\" =\"\" =\"\"</pre></div><p>When this form is submitted, the server will detect the missing CSRF token in the body and block the request. If the attacker includes an invalid token, the server will still reject the request upon recognizing that the token doesn't match the session's expected token.</p><p>In our application HTML template, we may share the token in the response in the form of a hidden field:</p><div><pre>=\"\" =\"\"\n\t/** CSRF token field **/\n\t=\"\" =\"\" =\"\"=\"\" =\"\"=\"\" =\"\"=\"\" </pre></div><p>When this form is submitted, the server will validate the CSRF token and allow the request.</p><p>Alternatively, if we use a JavaScript single page application (SPA), the server may share the CSRF token in a  tag:</p><div><pre></pre></div><p>The client reads it and includes it as a header when submitting a request:</p><div><pre>: : </pre></div><p>Finally, some popular JavaScript libraries (like <a href=\"https://v17.angular.io/guide/http-security-xsrf-protection\" rel=\"nofollow\">AngularJS</a> and <a href=\"https://axios-http.com/docs/req_config\" rel=\"nofollow\">Axios</a>) read the CSRF token from a cookie named . If we include this cookie in the response, the library will read it and send its value back on every request in the form of a  header.</p><div><h2>Adding CSRF Protection to the Session Manager</h2><a aria-label=\"Permalink: Adding CSRF Protection to the Session Manager\" href=\"https://themsaid.com/csrf-protection-go-web-applications#adding-csrf-protection-to-the-session-manager\"></a></div><p>Building on our <a href=\"https://themsaid.com/building-secure-session-manager-in-go\" rel=\"nofollow\">previous implementation</a> of a secure session manager in Go, we will now add CSRF protection to the session manager. This involves generating CSRF tokens, storing them in the session, and ensuring they are included with every state-changing request (POST, PUT, DELETE, and PATCH).</p><p>To generate a CSRF token, we will add a function that creates a 42-character base64 string with 256 bits of randomness:</p><div><pre>()  {\n\t([], )\n\n\t, .(., )\n\t {\n\t\t()\n\t}\n\n\t..()\n}</pre></div><p>Then, we'll ensure that a fresh CSRF token is created with every new session:</p><div><pre>()  {\n\t{\n\t\t:             (),\n\t\t:           []{: ()},\n\t\t:      .(),\n\t\t: .(),\n\t}\n}</pre></div><div><h3>Validating the CSRF Token</h3><a aria-label=\"Permalink: Validating the CSRF Token\" href=\"https://themsaid.com/csrf-protection-go-web-applications#validating-the-csrf-token\"></a></div><p>We will add a method to the session manager that extracts the CSRF token from a given session and validates it against the  form value or the  header:</p><div><pre> () (http., )  {\n\t, .().()\n\t {\n\t\t\n\t}\n\n\t.()\n\n\t {\n\t\t..()\n\t}\n\n\t\n}</pre></div><p>It's important to note that the form field name () and header name () are not fixed and can be customized. Here, I'm using common naming conventions for convenience. However, in your application, you may choose unique, less predictable names to add an extra layer of security.</p><div><h3>Performing the Validation</h3><a aria-label=\"Permalink: Performing the Validation\" href=\"https://themsaid.com/csrf-protection-go-web-applications#performing-the-validation\"></a></div><p>In our session manager's middleware, we will call the  method in the beginning of state-changing requests (POST, PUT, PATCH &amp; DELETE) and fail the request if the token doesn't match what's in the session:</p><div><pre>........ {\n\n\t.(, ) {\n\t\t.(, , .)\n\t\t\n\t}\n\n}\n\n.(, )</pre></div><p>With this setup, any state-changing request will be blocked before reaching the next handler in the chain, preventing an attacker from executing critical business logic.</p><p>The full code of the  method now looks like this:</p><div><pre> () ( http.) http. {\n\t.(( http., http.) {\n\t\t, .()\n\n\t\t{\n\t\t\t: ,\n\t\t\t: ,\n\t\t\t:        ,\n\t\t}\n\n\t\t.().(, )\n\t\t.().(, )\n\n\t\t........ {\n\t\t\t.(, ) {\n\t\t\t\t.(, , .)\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t.(, )\n\n\t\t.()\n\n\t\t()\n\t})\n}</pre></div><div><h2>Using CSRF in the Web Application</h2><a aria-label=\"Permalink: Using CSRF in the Web Application\" href=\"https://themsaid.com/csrf-protection-go-web-applications#using-csrf-in-the-web-application\"></a></div><p>As we mentioned earlier, there are multiple ways to pass the CSRF token in the application responses:</p><ol></ol><p>If the frontend of our application submits typical HTML forms, we may pass the CSRF token down to the template as a template data parameter:</p><div><pre>.()\n\n.().()\n\n[]{\n\t: ,\n}\n\n.(, )</pre></div><p>Then, inside our form, we add a hidden field that includes the CSRF token:</p><div><pre>=\"\" =\"\"=\"\" =\"\" =\"\"=\"\" </pre></div><p>In the same way, we may include the CSRF token in a meta tag and read the value via JavaScript if the frontend uses JavaScript to submit forms:</p><div><pre>=\"\" =\"\"</pre></div><div><pre>: : </pre></div><p>Finally, if we're using a JavaScript library that supports the  cookie, we may send that cookie in the handler that presents the SPA view to the browser:</p><div><pre>.()\n\n.().()\n\nhttp.{\n\t:     ,\n\t:    ,\n\t:   ,\n\t: ,\n\t:     ,\n\t:   ,\n\t: .,\n}\n\n.(, )</pre></div><p>Storing the session ID in a secure cookie, which browsers only send for requests originating from the same domain, is an important security measure but is not enough to fully protect users from request forgery. To strengthen security, the token validation pattern presented in this article adds a crucial layer of protection.</p><p>By incorporating CSRF tokens into session management, we ensure that each request made to the server is not only coming from a trusted origin but also includes a valid token that proves the request was intentionally generated by the user. This pattern helps prevent malicious actors from exploiting session cookies to perform unauthorized actions on behalf of the user.</p>","contentLength":7704,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1j9jh19/implementing_crosssite_request_forgery_csrf/"},{"title":"Go module is just too well designed","url":"https://www.reddit.com/r/golang/comments/1j9aii3/go_module_is_just_too_well_designed/","date":1741752013,"author":"/u/greengoguma","guid":336,"unread":true,"content":"<ol><li>Ability to pull directly from Git removes the need for repository manager.</li><li>Requiring major version in the module name after v1 allows a project to import multiple major versions at the same time.</li><li>Dependency management built into the core language removes the need to install additional tools</li><li>No pre-compiled package imports like Jar so my IDE can go to the definition without decompiling.</li></ol><p>These, such simple design choices, made me avoid a lot of pain points I faced while working in another language. No need to install npm, yarn or even wonder what the difference between the two is. No dependencies running into each other.</p><p>I simply do  and it works. Just. Amazing.</p>","contentLength":663,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Why isnâ€™t Go used for game development, even though it performs better than C#?","url":"https://www.reddit.com/r/golang/comments/1j99a3x/why_isnt_go_used_for_game_development_even_though/","date":1741747939,"author":"/u/mohamed_essam_salem","guid":335,"unread":true,"content":"<p>I've been wondering why Go (Golang) isn't commonly used for game development, despite the fact that it generally has better raw performance than C#. Since Go compiles to machine code and has lightweight concurrency (goroutines), it should theoretically be a strong choice.</p><p>Yet, C# (which is JIT-compiled and typically slower in general applications) dominates game development, mainly because of Unity. Is it just because of the lack of engines and libraries, or is there something deeperâ€”like Goâ€™s garbage collection, lack of low-level control, or weaker GPU supportâ€”that makes it unsuitable for real-time game development?</p><p>Would love to hear thoughts from developers who have tried using Go for games!</p>","contentLength":707,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I wrote a concurrent log parser in Go to learn about concurrency","url":"https://www.reddit.com/r/golang/comments/1j94d6e/i_wrote_a_concurrent_log_parser_in_go_to_learn/","date":1741734163,"author":"/u/Tack1234","guid":334,"unread":true,"content":"<p>I wanted to learn about using Go for concurrent tasks (e.g. using goroutines and channels), so I built a tool to solve a real problem I had at work. I wanted to parse CLF (e.g. Apache or Nginx) logs and store them in SQLite so I would be able to perform further data analysis on them without having to resort to \"heavier\" tools like Grafana.</p><p>It is mostly meant as a practice project but maybe someone else could also find it handy someday. </p><p>It is a little rough around the edges but overall I achieved with it what I set out to do and working on it over the last few weeks has taught me a lot about Golang as a newbie. Coming from the overcomplicated world of Node.js (both on the frontend and backend), I've been loving the simplicity of Go!</p>","contentLength":740,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"gotmux - Go library for tmux","url":"https://github.com/GianlucaP106/gotmux","date":1741725190,"author":"/u/One_Mess_1093","guid":331,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1j90umi/gotmux_go_library_for_tmux/"},{"title":"Iâ€™m porting over smolagents to go, interested developers?","url":"https://www.reddit.com/r/golang/comments/1j8z3js/im_porting_over_smolagents_to_go_interested/","date":1741720888,"author":"/u/wait-a-minut","guid":333,"unread":true,"content":"<p>Python has been dominating the AI tooling space but not much longer. The whole agent movement is heavily reliant on networking patterns, microservices, orchestrations etc which makes Go absolutely perfect for this </p><p>Iâ€™ve really liked the approach hugging face took with smolagents which is NOT bloated and overly abstracted thing like langchain. </p><p>Itâ€™s minimal and manages just state, orchestration, and tools. Which is what agents are. </p><p>Anyone want to help me fully port this lib over to go so we can finally let go shine in the AI agent department?</p>","contentLength":549,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","go"]}