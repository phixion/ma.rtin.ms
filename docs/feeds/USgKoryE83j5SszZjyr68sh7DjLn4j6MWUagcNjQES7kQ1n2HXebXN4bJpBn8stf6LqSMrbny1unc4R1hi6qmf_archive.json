{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Convex Optimization (or Mathematical Programming) in Go","url":"https://www.reddit.com/r/golang/comments/1ols1gn/convex_optimization_or_mathematical_programming/","date":1762014224,"author":"/u/RobotCyclist23","guid":415,"unread":true,"content":"<p>Do you write a lot of Convex (or similar) Optimization problems and have been yearning for a way to model them in Go? <a href=\"https://github.com/MatProGo-dev/MatProInterface.go\">MatProInterface.go</a> can help you (and needs your input to gain more maturity)! Feel free to try it and let me know what you think!</p>","contentLength":247,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go's Context Logger","url":"https://github.com/pablovarg/contextlogger?tab=readme-ov-file#examples","date":1762007053,"author":"/u/PurityHeadHunter","guid":416,"unread":true,"content":"<p>Hello Gophers! A while ago, I started using contextual logging in my projects and found it made debugging significantly easier. Being able to trace request context through your entire call stack is a game-changer for understanding what's happening in your system.</p><p>This project started as a collection of utility functions I copy-pasted between projects. Eventually, it grew too large to maintain that way, so I decided to turn it into a proper library and share it with the community. <a href=\"https://github.com/PabloVarg/contextlogger\">https://github.com/PabloVarg/contextlogger</a></p><p>Context Logger is a library that makes it easy to propagate your logging context through Go's  and integrates seamlessly with Go's standard library, mainly  and . If this is something that you usually use or you're interested on using it for your projects, take a look at some <a href=\"https://github.com/pablovarg/contextlogger\">Usage Examples</a>.</p><p>For a very simple example, here you can see how to:</p><ul><li>Embed a logger into your context</li><li>Update the context (this can be done many times before logging)</li><li>Log everything that you have included in your context so far</li></ul><pre><code>ctx = contextlogger.EmbedLogger(ctx) contextlogger.UpdateContext(ctx, \"userID\", user.ID) contextlogger.LogWithContext(ctx, slog.LevelInfo, \"done\") </code></pre>","contentLength":1171,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1olp424/gos_context_logger/"},{"title":"Java Virtual Threads VS GO routines","url":"https://www.reddit.com/r/golang/comments/1oldyoo/java_virtual_threads_vs_go_routines/","date":1761967558,"author":"/u/gamecrow77","guid":414,"unread":true,"content":"<p>I recently had a argument with my tech lead about this , my push was for Go since its a new stack , new learning for the team and Go is evolving , my assumption is that we will find newer gen of devs who specialise in Go. Was i wrong here ? the argument was java with virtual threads is as efficient as go </p>","contentLength":306,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[GoGreement] A new linter that can help enforce interface implementation and immutability","url":"https://www.reddit.com/r/golang/comments/1ol8das/gogreement_a_new_linter_that_can_help_enforce/","date":1761950330,"author":"/u/Green-Sympathy-2198","guid":417,"unread":true,"content":"<p>Hey guys! I wrote this linter mainly for myself, but I hope some of you find it useful.</p><p>I came to golang from JVM world and I was missing some things like explicit implementation declaration and immutability.</p><p>But I see gophers love their linters, so I thought I could solve this with a linter.</p><p>How does it work? You just add annotations to your types like: <code>go // @immutable type User struct { id string name string } </code></p><p>And run the linter and it will give you an error if you try to change fields like this: </p><p>I also added annotations that let you check interface implementation: <code>go // @implements io.Reader </code></p><p>This lets you check that a struct actually implements an interface without all this stuff: <code>go var _ MyInterface = (*MyStruct)(nil) </code></p><p>And many other annotations (testonly, packageonly, ...). Would love to hear what you think!</p>","contentLength":822,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Write PostgreSQL functions in Go Golang example","url":"https://www.reddit.com/r/golang/comments/1ol2tqv/write_postgresql_functions_in_go_golang_example/","date":1761936351,"author":"/u/WinProfessional4958","guid":419,"unread":true,"content":"<p>It took me a while to figure this out. Go compiles the C files automatically.</p><pre><code>#include \"postgres.h\" #include \"fmgr.h\" PG_MODULE_MAGIC; extern int32 Adder(int32); PG_FUNCTION_INFO_V1(add_two); Datum add_two(PG_FUNCTION_ARGS) { int32 arg = PG_GETARG_INT32(0); PG_RETURN_INT32(Adder(arg)); } </code></pre><pre><code>package main /* #cgo CFLAGS: -DWIN32 -ID:/pg18headers -ID:/pg18headers/port/win32 #cgo LDFLAGS: -LD:/pg18lib #include \"postgres.h\" #include \"fmgr.h\" // Forward declare the C function so cgo compiles add_two.c too. extern void init_add_two(); */ import \"C\" //export Adder func Adder(a C.int32) C.int32 { return a + 3 } func main() {} </code></pre><p><code>PS D:\\C\\myextension&gt; go build -o add_two.dll -buildmode=c-shared</code></p><p>In PostgreSQL: open the query window (adjust path to your generated dynamically loaded library and header file (.dll, .h).</p><p><code>CREATE FUNCTION add_two(int4) RETURNS int4</code></p><p><code>AS 'D:/C/myextension/add_two.dll', 'add_two'</code></p>","contentLength":893,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go vs Kotlin: Server throughput","url":"https://www.reddit.com/r/golang/comments/1ol1upp/go_vs_kotlin_server_throughput/","date":1761934095,"author":"/u/iG0tB00ts","guid":418,"unread":true,"content":"<p>Let me start off by saying I'm a big fan of Go. Go is my side love while Kotlin is my official (work-enforced) love. I recognize benchmarks do not translate to real world performance &amp; I also acknowledge this is the first benchmark I've made, so mistakes are possible.</p><p>That being said, I was recently tasked with evaluating Kotlin vs Go for a small service we're building. This service is a wrapper around Redis providing a REST API for checking the existence of a key.</p><p>With a load of 30,000 RPS in mind, I ran a benchmark using  (the workload is a list of newline separated 40chars string) and saw to my surprise Kotlin outperforming Go by ~35% RPS. Surprise because my thoughts, few online searches as well as AI prompts led me to believe Go would be the winner due to its lightweight and performant goroutines.</p><p>Go + net/http + go-redis <code>Text Thread Stats Avg Stdev Max +/- Stdev Latency 4.82ms 810.59us 38.38ms 97.05% Req/Sec 5.22k 449.62 10.29k 95.57% 105459 requests in 5.08s, 7.90MB read Non-2xx or 3xx responses: 53529 Requests/sec: 20767.19 </code> Kotlin + ktor + lettuce <code> Thread Stats Avg Stdev Max +/- Stdev Latency 3.63ms 1.66ms 52.25ms 97.24% Req/Sec 7.05k 0.94k 13.07k 92.65% 143105 requests in 5.10s, 5.67MB read Non-2xx or 3xx responses: 72138 Requests/sec: 28057.91 </code></p><p>I am in no way an expert with the Go ecosystem, so I was wondering if anyone had an explanation for the results or suggestions on improving my Go code. ```Go package main</p><p>import ( \"context\" \"net/http\" \"runtime\" \"time\"</p><pre><code>\"github.com/redis/go-redis/v9\" </code></pre><p>var ( redisClient *redis.Client )</p><p>func main() { redisClient = redis.NewClient(&amp;redis.Options{ Addr: \"localhost:6379\", Password: \"\", DB: 0, PoolSize: runtime.NumCPU() * 10, MinIdleConns: runtime.NumCPU() * 2, MaxRetries: 1, PoolTimeout: 2 * time.Second, ReadTimeout: 1 * time.Second, WriteTimeout: 1 * time.Second, }) defer redisClient.Close()</p><pre><code>mux := http.NewServeMux() mux.HandleFunc(\"/\", handleKey) server := &amp;http.Server{ Addr: \":8080\", Handler: mux, } server.ListenAndServe() // some code for quitting on exit signal </code></pre><p>// handleKey handles GET requests to /{key} func handleKey(w http.ResponseWriter, r *http.Request) { path := r.URL.Path</p><pre><code>key := path[1:] exists, _ := redisClient.Exists(context.Background(), key).Result() if exists == 0 { w.WriteHeader(http.StatusNotFound) return } </code></pre><p>Kotlin code for reference ```Kotlin // application</p><p>fun main(args: Array&lt;String&gt;) { io.ktor.server.netty.EngineMain.main(args) }</p><p>fun Application.module() { val redis = RedisClient.create(\"redis://localhost/\"); val conn = redis.connect() configureRouting(conn) }</p><p>fun Application.configureRouting(connection: StatefulRedisConnection&lt;String, String&gt;) { val api = connection.async()</p><pre><code>routing { get(\"/{key}\") { val key = call.parameters[\"key\"]!! val exists = api.exists(key).await() &gt; 0 if (exists) { call.respond(HttpStatusCode.OK) } else { call.respond(HttpStatusCode.NotFound) } } } </code></pre>","contentLength":2876,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","go"]}