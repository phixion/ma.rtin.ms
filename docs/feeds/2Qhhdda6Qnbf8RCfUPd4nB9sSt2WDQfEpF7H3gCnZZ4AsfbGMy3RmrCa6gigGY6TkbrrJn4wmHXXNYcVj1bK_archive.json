{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Cycle-accurate 6502 emulator as coroutine in Rust","url":"https://github.com/bagnalla/6502","date":1762008293,"author":"/u/bagnalla","guid":476,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1olpls5/cycleaccurate_6502_emulator_as_coroutine_in_rust/"},{"title":"Async Rust explained without Tokio or Smol","url":"https://youtu.be/_x61dSP4ZKM?si=XPDtuH13Du-s5KTD","date":1762005654,"author":"/u/Gisleburt","guid":478,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1olokba/async_rust_explained_without_tokio_or_smol/"},{"title":"Hard Rust requirements from May onward (for Debian's package manager, APT)","url":"https://lists.debian.org/debian-devel/2025/10/msg00285.html","date":1761999882,"author":"/u/DeleeciousCheeps","guid":480,"unread":true,"content":"<pre>Hi all,\n\nI plan to introduce hard Rust dependencies and Rust code into\nAPT, no earlier than May 2026. This extends at first to the\nRust compiler and standard library, and the Sequoia ecosystem.\n\nIn particular, our code to parse .deb, .ar, .tar, and the\nHTTP signature verification code would strongly benefit\nfrom memory safe languages and a stronger approach to\nunit testing.\n\nIf you maintain a port without a working Rust toolchain,\nplease ensure it has one within the next 6 months, or\nsunset the port.\n\nIt's important for the project as whole to be able to\nmove forward and rely on modern tools and technologies\nand not be held back by trying to shoehorn modern software\non retro computing devices.\n\nThank you for your understanding.\n-- \ndebian developer - deb.li/jak | jak-linux.org - free software dev\nubuntu core developer                              i speak de, en\n</pre>","contentLength":874,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1olmhxe/hard_rust_requirements_from_may_onward_for/"},{"title":"Prevent laptop's temp raises significantly during compiling","url":"https://www.reddit.com/r/rust/comments/1olfwxy/prevent_laptops_temp_raises_significantly_during/","date":1761974575,"author":"/u/blade_012","guid":475,"unread":true,"content":"<p>When compiling <a href=\"http://fyrox.rs\">Fyrox</a> for the first time, my laptop temperature raised significantly from 40°C to 90°C and stays in 90°C for long time until the compilation done. </p><p>Is there any way to cap the compilation activity so that it won't use up all my CPU during the process? I don't mind having the process take a bit longer as long it's safe for my poor small Dell Latitude 7290.</p>","contentLength":374,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Borrow checker says “No”! An error that scares me every single time!","url":"https://polymonster.co.uk/blog/borow-checker-says-no","date":1761949509,"author":"/u/__shufb","guid":477,"unread":true,"content":"<p>It’s Halloween and I have just been caught out by a spooky borrow checker error that caught me by surprise. It feels as though it is the single most time consuming issue to fix and always seems to catch me unaware. The issue in particular is “cannot borrow x immutably as it is already borrowed mutably” - it manifests itself in different ways under different circumstances, but I find myself hitting it often when refactoring. It happened again recently so I did some investigating and thought I would discuss it in more detail.</p><p>The issue last hit me when I was refactoring some code in my graphics engine <a href=\"https://github.com/polymonster/hotline\">hotline</a>, I have been creating some content on YouTube and, after a little bit of a slog to fix the issue, I recorded a video of me going through the scenario of how it occurred and some patterns to use that I have adopted in the past to get around it. You can check out the video if you are that way inclined, the rest of this post will mostly echo what is in the video, but it might be a bit easier to follow code snippets and description in text.</p><p>I have a generic graphics API, which consists of traits called <a href=\"https://github.com/polymonster/hotline/blob/master/src/gfx.rs\">gfx</a>. This is there to allow different platform backends to implement the trait; currently I have a fully implemented Direct3D12 backend and I recently began to port macOS using Metal.</p><p>The gfx backend wraps underlying graphics API primitives; in this case we are mostly concerned about  which is a command buffer. Command buffers are used to submit commands to the GPU. They do things like  or , amongst other things. For the purposes of this blog post, what the command buffer does is not really that important, just that is does , which at the starting point when the code was working is a trait method that takes an immutable self and another immutable parameter ie. <code>fn do_something(&amp;self, param: &amp;Param)</code>.</p><p>In the rest of the code base I have a higher level rendering system called . This is graphics engine code that is not platform specific but implements shared functionality. So where  is a low level abstraction layer,  implements concepts of a  that is a view of a scene that we can render from. A  has a camera that can look at the scene and is then passed to a render function, which can build a command buffer to render the scene from that camera’s perspective. The engine is designed to be multithreaded and render functions are dispatched through  systems, so a view gets passed into a render system but it is wrapped in an .</p><p>I made a small cutdown example of this code to be able to demonstrate the problem I encounter, so let’s start with the initial working version:</p><div><div><pre><code></code></pre></div></div><p>I tried to simplify it as much as possible so these snippets should compile if you copy and paste them, they won’t run thanks to  macro (which I absolutely love using, it is so handy!) but we only care about the borrow checker anyway.</p><p>All we really need to think about is that a  can  and it also gets passed in a , which is also contained as part of ‘view’. Coming from a C/C++ background I landed on my personal preference being procedural C code with context passing, so I tend to group things together into a single struct. It makes sense to me in this case and I wanted to group everything inside , and we fetch the view from elsewhere in the engine.</p><p>So the code in the snippet compiles fine and I was working with this setup for some time. I began work on macOS and it turned out that the  method needed to mutate the command buffer so that I could mutate some internal state and make the Metal graphics API behave similarly to Direct3D12. This is common for graphics API plumbing.</p><p>The specific example in this case was that in Direct3D we call a function  to bind an index buffer before we make a call to , but in Metal there is no equivalent to bind an index buffer. Instead you pass a pointer to your index buffer when calling the equivalent draw indexed. So to fix this, when we call  we can store some extra state in the command buffer so we can pass it in the later call to .</p><p>In hindsight any method on the command buffer trait that does anything, like set anything or write into the command buffer, should take a  because it is mutating the command buffer after all. In my case since I am calling through to methods on  , which is unsafe code and does not require any mutable references.</p><p>In our simplified example, in order to store, state  now needs to change and take a mutable self: <code>do_something(&amp;mut self, param: &amp;Param)</code> it should be noted that  itself was already .</p><div><div><pre><code></code></pre></div></div><p>Borrow checker now kicks in…my heart sinks. In the real code base not only did I have to modify a single call site, but I had hundreds of places where this error was happening, I made the decision here and now to make any methods that write to the command buffer also be mutable and make the mutability</p><div><div><pre><code>error[E0502]: cannot borrow `view` as immutable because it is also borrowed as mutable\n  --&gt; src/main.rs:30:28\n   |\n30 |     view.cmd.do_something(&amp;view.param);\n   |     ----     ------------  ^^^^ immutable borrow occurs here\n   |     |        |\n   |     |        mutable borrow later used by call\n   |     mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile due to 1 previous error\n</code></pre></div></div><p>This is not the first time I have encountered this problem and I doubt it will be the last. There are a number of ways to resolve it and they aren’t too complicated. The frustrating thing is that it seems to occur always when you are doing something else and not just when you decide to refactor, so you end up having a mountain of errors to solve before you can get back to the original task. I suppose you could call it a symptom of bad design or lack of experience, but when writing code things inevitably change and bend with new requirements, and Rust throws these unexpected issues up for me more often than I find with C, and often the required refactor takes more effort as well. But that is the cost you pay, hopefully more upfront effort to get past the borrow checker means fewer nasty debugging stages later. So let’s look at some patterns to fix the issue!</p><p>The one I actually went for in this case was using . We take the  out of view so we no longer need to borrow a ‘view’ to use , and then when finished return the cmd into ‘view’. It is important to note here that  needs to derive default in order for this to work, as when we take the  in  will become </p><div><div><pre><code></code></pre></div></div><p>This approach is the simplest I could think of at the time because any existing code using  doesn’t need updating, everything stays the same and we just separate the references. In this case it was easy to derive the default for  .You need to remember to set the  back on  here, which could be a pitfall and cause unexpected behaviour if you didn’t.</p><p>If you can’t easily derive default on a struct there are some other options. If the struct is clonable or you can easily derive a clone, you can clone to achieve a similar effect.</p><div><div><pre><code></code></pre></div></div><p>Cloning might be considered a heavier operation than ‘take’ depending on the circumstances, but this method has the same benefit as the take version whereby unaffected code that is using  elsewhere doesn’t need to be changed.</p><p>Another approach would be to use  this allows for interior mutability and again we do not need to worry about default or clone.</p><div><div><pre><code></code></pre></div></div><p>We also need to update any code that ever used  and do the same. Not ideal but it allows us to get around the need for a default or clone. I have had to resort to this in other places in the code base.</p><p>There are more options; quite literally  here can help. If we make  an  then this gives us the ability to use  as the default and we can use the  approach. We can also use  and swap with . Swapping works similar to ‘take’, where we take mem and swap with the default.</p><div><div><pre><code></code></pre></div></div><p>The  approach also requires more effort as we need to now take a reference and unwrap the option and update any code that ever used  to do the same. Not ideal, but it allows us to get around the need for a default or clone, and if your type is already optional then this will fit easily.</p><p>There is one final approach that could save a lot of time, and that would be to not change the  function at all in the first place. That is to keep it as <code>do_something(&amp;self, param: &amp;Param)</code>. So how do we mutate the interior state without requiring the self to be mutable?</p><p>This can be done with  in single threaded code or  in multithreaded code. Since we already looked at  I will do an example of .</p><div><div><pre><code></code></pre></div></div><p>I decided to make the mutability explicit to the trait and that was based on how the command buffers are used in the engine, in other places I have taken other approaches favouring interior mutability. For this case a view can be dispatched in parallel with other views, but the engine is designed such that 1 thread per view and no work happens to a single view on multiple threads at the same time. Command buffers are submitted in a queue in order and dispatched on the GPU.</p><p>Here it made sense to me to avoid locking interior mutability for each time we call a method on a  and it works with the engine’s design. We lock a view at the start of a render thread, fill it with commands and then hand it back to the graphics engineer for submission to the GPU. The usage is explicit, we just needed to appease the borrow checker!</p><p>I hope you enjoyed this article, please check out my <a href=\"https://www.youtube.com/@polymonster\">YouTube channel</a> for more videos or more articles on my blog, let me know what you think and if you have any other strategies or approaches I would love to hear about them. I would also like to hear about compiler and borrow checker errors you find particularly time consuming or frustrating to deal with.</p>","contentLength":9662,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ol82h6/borrow_checker_says_no_an_error_that_scares_me/"},{"title":"Futurelock - Subtle Risk in async Rust","url":"https://rfd.shared.oxide.computer/rfd/0609","date":1761942015,"author":"/u/-Y0-","guid":479,"unread":true,"content":"<div data-lineno=\"424\"><p>Bounded channels are not really the issue here.  Even in omicron#9259, the capacity=1 channel was basically behaving as documented and as one would expect.  It woke up a sender when capacity was available, and the other senders were blocked to maintain the documented FIFO property.  However, some of the patterns that we use with bounded channels are problematic on their own and, if changed, could prevent the channel from getting caught up in a futurelock.</p></div><div data-lineno=\"426\"><p>In Omicron, we commonly use bounded channels with .  The bound is intended to cap memory usage and provide backpressure, but using the blocking  creates a second  queue: the wait queue for the channel.  Instead, we could consider using a larger capacity channel plus  and propagate failure from .</p></div><div data-lineno=\"428\"><p>As an example, when we use the actor pattern, we typically observe that there’s only one actor and potentially many clients, so there’s not much point in buffering messages  the channel.  So we use  and let clients block in .  But we could instead have  and have clients use  and propagate failure if they’re unable to send the message.  The value  here is pretty arbitrary.  You want it to be large enough to account for an expected amount of client concurrency, but not larger.  If the value is too small, you’ll wind up with spurious failures when the client could have just waited a bit longer.  If the value is too large, you can wind up queueing so much work that the actor is always behind (and clients are potentially even timing out at a higher level).  One might observe:</p></div><div data-lineno=\"430\"><div data-lineno=\"1\"><p>Channel limits, channel limits: always wrong!</p></div><div data-lineno=\"3\"><p>Some too short and some too long!</p></div></div><div data-lineno=\"434\"><p>But as with timeouts, it’s often possible to find values that work in practice.</p></div><div data-lineno=\"436\"><p>Using  is  a mitigation because this still results in the sender blocking.  It needs to be polled after the timeout expires in order to give up.  But with futurelock, it will never be polled.</p></div>","contentLength":1894,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ol566h/futurelock_subtle_risk_in_async_rust/"}],"tags":["dev","reddit","rust"]}