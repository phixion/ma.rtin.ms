{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":1,"items":[{"title":"The Green Tea Garbage Collector","url":"https://go.dev/blog/greenteagc","date":1761696000,"author":"Michael Knyszek and Austin Clements","guid":98,"unread":true,"content":"<p>Go 1.25 includes a new experimental garbage collector called Green Tea,\navailable by setting  at build time.\nMany workloads spend around 10% less time in the garbage collector, but some\nworkloads see a reduction of up to 40%!</p><p>It’s production-ready and already in use at Google, so we encourage you to\ntry it out.\nWe know some workloads don’t benefit as much, or even at all, so your feedback\nis crucial to helping us move forward.\nBased on the data we have now, we plan to make it the default in Go 1.26.</p><p>What follows is a blog post based on Michael Knyszek’s GopherCon 2025 talk.\nWe’ll update this blog post with a link to the talk once it’s available online.</p><h2>Tracing garbage collection</h2><p>Before we discuss Green Tea let’s get us all on the same page about garbage\ncollection.</p><p>The purpose of garbage collection is to automatically reclaim and reuse memory\nno longer used by the program.</p><p>To this end, the Go garbage collector concerns itself with  and\n.</p><p>In the context of the Go runtime,  are Go values whose underlying\nmemory is allocated from the heap.\nHeap objects are created when the Go compiler can’t figure out how else to allocate\nmemory for a value.\nFor example, the following code snippet allocates a single heap object: the backing\nstore for a slice of pointers.</p><pre><code>var x = make([]*int, 10) // global\n</code></pre><p>The Go compiler can’t allocate the slice backing store anywhere except the heap,\nsince it’s very hard, and maybe even impossible, for it to know how long  will\nrefer to the object for.</p><p> are just numbers that indicate the location of a Go value in memory,\nand they’re how a Go program references objects.\nFor example, to get the pointer to the beginning of the object allocated in the\nlast code snippet, we can write:</p><p>Go’s garbage collector follows a strategy broadly referred to as <em>tracing garbage\ncollection</em>, which just means that the garbage collector follows, or traces, the\npointers in the program to identify which objects the program is still using.</p><p>More specifically, the Go garbage collector implements the mark-sweep algorithm.\nThis is much simpler than it sounds.\nImagine objects and pointers as a sort of graph, in the computer science sense.\nObjects are nodes, pointers are edges.</p><p>The mark-sweep algorithm operates on this graph, and as the name might suggest,\nproceeds in two phases.</p><p>In the first phase, the mark phase, it walks the object graph from well-defined\nsource edges called .\nThink global and local variables.\nThen, it  everything it finds along the way as , to avoid going in\ncircles.\nThis is analogous to your typical graph flood algorithm, like a depth-first or\nbreadth-first search.</p><p>Next is the sweep phase.\nWhatever objects were not visited in our graph walk are unused, or ,\nby the program.\nWe call this state unreachable because it is impossible with normal safe Go code\nto access that memory anymore, simply through the semantics of the language.\nTo complete the sweep phase, the algorithm simply iterates through all the\nunvisited nodes and marks their memory as free, so the memory allocator can reuse\nit.</p><p>You may think I’m oversimplifying a bit here.\nGarbage collectors are frequently referred to as , and .\nAnd you’d be partially right, there are more complexities.</p><p>For example, this algorithm is, in practice, executed concurrently with your\nregular Go code.\nWalking a graph that’s mutating underneath you brings challenges.\nWe also parallelize this algorithm, which is a detail that’ll come up again\nlater.</p><p>But trust me when I tell you that these details are mostly separate from the\ncore algorithm.\nIt really is just a simple graph flood at the center.</p><p>Let’s walk through an example.\nNavigate through the slideshow below to follow along.</p><p>After all that, I think we have a handle on what the Go garbage collector is actually doing.\nThis process seems to work well enough today, so what’s the problem?</p><p>Well, it turns out we can spend  of time executing this particular algorithm in some\nprograms, and it adds substantial overhead to nearly every Go program.\nIt’s not that uncommon to see Go programs spending 20% or more of their CPU time in the\ngarbage collector.</p><p>Let’s break down where that time is being spent.</p><p>At a high level, there are two parts to the cost of the garbage collector.\nThe first is how often it runs, and the second is how much work it does each time it runs.\nMultiply those two together, and you get the total cost of the garbage collector.</p><figure><figcaption>\n    Total GC cost = Number of GC cycles × Average cost per GC cycle\n    </figcaption></figure><p>But for now let’s focus only on the second part, the cost per cycle.</p><p>From years of poring over CPU profiles to try to improve performance, we know two big things\nabout Go’s garbage collector.</p><p>The first is that about 90% of the cost of the garbage collector is spent marking,\nand only about 10% is sweeping.\nSweeping turns out to be much easier to optimize than marking,\nand Go has had a very efficient sweeper for many years.</p><p>The second is that, of that time spent marking, a substantial portion, usually at least 35%, is\nsimply spent  on accessing heap memory.\nThis is bad enough on its own, but it completely gums up the works on what makes modern CPUs\nactually fast.</p><h3>“A microarchitectural disaster”</h3><p>What does “gum up the works” mean in this context?\nThe specifics of modern CPUs can get pretty complicated, so let’s use an analogy.</p><p>Imagine the CPU driving down a road, where that road is your program.\nThe CPU wants to ramp up to a high speed, and to do that it needs to be able to see far ahead of it,\nand the way needs to be clear.\nBut the graph flood algorithm is like driving through city streets for the CPU.\nThe CPU can’t see around corners and it can’t predict what’s going to happen next.\nTo make progress, it constantly has to slow down to make turns, stop at traffic lights, and avoid\npedestrians.\nIt hardly matters how fast your engine is because you never get a chance to get going.</p><p>Let’s make that more concrete by looking at our example again.\nI’ve overlaid the heap here with the path that we took.\nEach left-to-right arrow represents a piece of scanning work that we did\nand the dashed arrows show how we jumped around between bits of scanning work.</p><p>Notice that we were jumping all over memory doing tiny bits of work in each place.\nIn particular, we’re frequently jumping between pages, and between different parts of pages.</p><p>Modern CPUs do a lot of caching.\nGoing to main memory can be up to 100x slower than accessing memory that’s in our cache.\nCPU caches are populated with memory that’s been recently accessed, and memory that’s nearby to\nrecently accessed memory.\nBut there’s no guarantee that any two objects that point to each other will  be close to each\nother in memory.\nThe graph flood doesn’t take this into account.</p><p>Quick side note: if we were just stalling fetches to main memory, it might not be so bad.\nCPUs issue memory requests asynchronously, so even slow ones could overlap if the CPU could see\nfar enough ahead.\nBut in the graph flood, every bit of work is small, unpredictable, and highly dependent on the\nlast, so the CPU is forced to wait on nearly every individual memory fetch.</p><p>And unfortunately for us, this problem is only getting worse.\nThere’s an adage in the industry of “wait two years and your code will get faster.”</p><p>But Go, as a garbage collected language that relies on the mark-sweep algorithm, risks the opposite.\n“Wait two years and your code will get slower.”\nThe trends in modern CPU hardware are creating new challenges for garbage collector performance:</p><p><strong>Non-uniform memory access.</strong>\nFor one, memory now tends to be associated with subsets of CPU cores.\nAccesses by  CPU cores to that memory are slower than before.\nIn other words, the cost of a main memory access <a href=\"https://jprahman.substack.com/p/sapphire-rapids-core-to-core-latency\" rel=\"noreferrer\" target=\"_blank\">depends on which CPU core is accessing\nit</a>.\nIt’s non-uniform, so we call this non-uniform memory access, or NUMA for short.</p><p><strong>Reduced memory bandwidth.</strong>\nAvailable memory bandwidth per CPU is trending downward over time.\nThis just means that while we have more CPU cores, each core can submit relatively fewer\nrequests to main memory, forcing non-cached requests to wait longer than before.</p><p>\nAbove, we looked at a sequential marking algorithm, but the real garbage collector performs this\nalgorithm in parallel.\nThis scales well to a limited number of CPU cores, but the shared queue of objects to scan becomes\na bottleneck, even with careful design.</p><p><strong>Modern hardware features.</strong>\nNew hardware has fancy features like vector instructions, which let us operate on a lot of data at once.\nWhile this has the potential for big speedups, it’s not immediately clear how to make that work for\nmarking because marking does so much irregular and often small pieces of work.</p><p>Finally, this brings us to Green Tea, our new approach to the mark-sweep algorithm.\nThe key idea behind Green Tea is astonishingly simple:</p><p><em>Work with pages, not objects.</em></p><p>Sounds trivial, right?\nAnd yet, it took a lot of work to figure out how to order the object graph walk and what we needed to\ntrack to make this work well in practice.</p><p>More concretely, this means:</p><ul><li>Instead of scanning objects we scan whole pages.</li><li>Instead of tracking objects on our work list, we track whole pages.</li><li>We still need to mark objects at the end of the day, but we’ll track marked objects locally to each\npage, rather than across the whole heap.</li></ul><p>Let’s see what this means in practice by looking at our example heap again, but this time\nrunning Green Tea instead of the straightforward graph flood.</p><p>As above, navigate through the annotated slideshow to follow along.</p><p>Let’s come back around to our driving analogy.\nAre we finally getting on the highway?</p><p>Let’s recall our graph flood picture before.</p><p>We jumped around a whole lot, doing little bits of work in different places.\nThe path taken by Green Tea looks very different.</p><p>Green Tea, in contrast, makes fewer, longer left-to-right passes over pages A and B.\nThe longer these arrows, the better, and with bigger heaps, this effect can be much stronger.\n the magic of Green Tea.</p><p>It’s also our opportunity to ride the highway.</p><p>This all adds up to a better fit with the microarchitecture.\nWe can now scan objects closer together with much higher probability, so\nthere’s a better chance we can make use of our caches and avoid main memory.\nLikewise, per-page metadata is more likely to be in cache.\nTracking pages instead of objects means work lists are smaller,\nand less pressure on work lists means less contention and fewer CPU stalls.</p><p>And speaking of the highway, we can take our metaphorical engine into gears we’ve never been able to\nbefore, since now we can use vector hardware!</p><p>If you’re only vaguely familiar with vector hardware, you might be confused as to how we can use it here.\nBut besides the usual arithmetic and trigonometric operations,\nrecent vector hardware supports two things that are valuable for Green Tea:\nvery wide registers, and sophisticated bit-wise operations.</p><p>Most modern x86 CPUs support AVX-512, which has 512-bit wide vector registers.\nThis is wide enough to hold all of the metadata for an entire page in just two registers,\nright on the CPU, enabling Green Tea to work on an entire page in just a few straight-line\ninstructions.\nVector hardware has long supported basic bit-wise operations on whole vector registers, but starting\nwith AMD Zen 4 and Intel Ice Lake, it also supports a new bit vector “Swiss army knife” instruction\nthat enables a key step of the Green Tea scanning process to be done in just a few CPU cycles.\nTogether, these allow us to turbo-charge the Green Tea scan loop.</p><p>This wasn’t even an option for the graph flood, where we’d be jumping between scanning objects that\nare all sorts of different sizes.\nSometimes you needed two bits of metadata and sometimes you needed ten thousand.\nThere simply wasn’t enough predictability or regularity to use vector hardware.</p><p>If you want to nerd out on some of the details, read along!\nOtherwise, feel free to skip ahead to the <a href=\"https://go.dev/blog/greenteagc#evaluation\">evaluation</a>.</p><p>To get a sense of what AVX-512 GC scanning looks like, take a look at the diagram below.</p><p>There’s a lot going on here and we could probably fill an entire blog post just on how this works.\nFor now, let’s just break it down at a high level:</p><ol><li><p>First we fetch the “seen” and “scanned” bits for a page.\nRecall, these are one bit per object in the page, and all objects in a page have the same size.</p></li><li><p>Next, we compare the two bit sets.\nTheir union becomes the new “scanned” bits, while their difference is the “active objects” bitmap,\nwhich tells us which objects we need to scan in this pass over the page (versus previous passes).</p></li><li><p>We take the difference of the bitmaps and “expand” it, so that instead of one bit per object,\nwe have one bit per word (8 bytes) of the page.\nWe call this the “active words” bitmap.\nFor example, if the page stores 6-word (48-byte) objects, each bit in the active objects bitmap\nwill be copied to 6 bits in the active words bitmap.\nLike so:</p></li></ol><figure><div> → <pre>000000 000000 111111 111111 ...</pre></div></figure><ol start=\"4\"><li><p>Next we fetch the pointer/scalar bitmap for the page.\nHere, too, each bit corresponds to a word (8 bytes) of the page, and it tells us whether that word\nstores a pointer.\nThis data is managed by the memory allocator.</p></li><li><p>Now, we take the intersection of the pointer/scalar bitmap and the active words bitmap.\nThe result is the “active pointer bitmap”: a bitmap that tells us the location of every\npointer in the entire page contained in any live object we haven’t scanned yet.</p></li><li><p>Finally, we can iterate over the memory of the page and collect all the pointers.\nLogically, we iterate over each set bit in the active pointer bitmap,\nload the pointer value at that word, and write it back to a buffer that\nwill later be used to mark objects seen and add pages to the work list.\nUsing vector instructions, we’re able to do this 64 bytes at a time,\nin just a couple instructions.</p></li></ol><p>Part of what makes this fast is the  instruction,\npart of the “Galois Field New Instructions” x86 extension,\nand the bit manipulation Swiss army knife we referred to above.\nIt’s the real star of the show, since it lets us do step (3) in the scanning kernel very, very\nefficiently.\nIt performs a bit-wise <a href=\"https://en.wikipedia.org/wiki/Affine_transformation\" rel=\"noreferrer\" target=\"_blank\">affine\ntransformations</a>,\ntreating each byte in a vector as itself a mathematical vector of 8 bits\nand multiplying it by an 8x8 bit matrix.\nThis is all done over the <a href=\"https://en.wikipedia.org/wiki/Finite_field\" rel=\"noreferrer\" target=\"_blank\">Galois field</a>,\nwhich just means multiplication is AND and addition is XOR.\nThe upshot of this is that we can define a few 8x8 bit matrices for each\nobject size that perform exactly the 1:n bit expansion we need.</p><p>For the full assembly code, see <a href=\"https://cs.opensource.google/go/go/+/master:src/internal/runtime/gc/scan/scan_amd64.s;l=23;drc=041f564b3e6fa3f4af13a01b94db14c1ee8a42e0\" rel=\"noreferrer\" target=\"_blank\">this\nfile</a>.\nThe “expanders” use different matrices and different permutations for each size class,\nso they’re in a <a href=\"https://cs.opensource.google/go/go/+/master:src/internal/runtime/gc/scan/expand_amd64.s;drc=041f564b3e6fa3f4af13a01b94db14c1ee8a42e0\" rel=\"noreferrer\" target=\"_blank\">separate file</a>\nthat’s written by a <a href=\"https://cs.opensource.google/go/go/+/master:src/internal/runtime/gc/scan/mkasm.go;drc=041f564b3e6fa3f4af13a01b94db14c1ee8a42e0\" rel=\"noreferrer\" target=\"_blank\">code generator</a>.\nAside from the expansion functions, it’s really not a lot of code.\nMost of it is dramatically simplified by the fact that we can perform most of the above\noperations on data that sits purely in registers.\nAnd, hopefully soon this assembly code <a href=\"https://go.dev/issue/73787\">will be replaced with Go code</a>!</p><p>Credit to Austin Clements for devising this process.\nIt’s incredibly cool, and incredibly fast!</p><p>So that’s it for how it works.\nHow much does it actually help?</p><p>It can be quite a lot.\nEven without the vector enhancements, we see reductions in garbage collection CPU costs\nbetween 10% and 40% in our benchmark suite.\nFor example, if an application spends 10% of its time in the garbage collector, then that\nwould translate to between a 1% and 4% overall CPU reduction, depending on the specifics of\nthe workload.\nA 10% reduction in garbage collection CPU time is roughly the modal improvement.\n(See the <a href=\"https://go.dev/issue/73581\">GitHub issue</a> for some of these details.)</p><p>We’ve rolled Green Tea out inside Google, and we see similar results at scale.</p><p>We’re still rolling out the vector enhancements,\nbut benchmarks and early results suggest this will net an additional 10% GC CPU reduction.</p><p>While most workloads benefit to some degree, there are some that don’t.</p><p>Green Tea is based on the hypothesis that we can accumulate enough objects to scan on a\nsingle page in one pass to counteract the costs of the accumulation process.\nThis is clearly the case if the heap has a very regular structure: objects of the same size at a\nsimilar depth in the object graph.\nBut there are some workloads that often require us to scan only a single object per page at a time.\nThis is potentially worse than the graph flood because we might be doing more work than before while\ntrying to accumulate objects on pages and failing.</p><p>The implementation of Green Tea has a special case for pages that have only a single object to scan.\nThis helps reduce regressions, but doesn’t completely eliminate them.</p><p>However, it takes a lot less per-page accumulation to outperform the graph flood\nthan you might expect.\nOne surprise result of this work was that scanning a mere 2% of a page at a time\ncan yield improvements over the graph flood.</p><p>Green Tea is already available as an experiment in the recent Go 1.25 release and can be enabled\nby setting the environment variable  to  at build time.\nThis doesn’t include the aforementioned vector acceleration.</p><p>We expect to make it the default garbage collector in Go 1.26, but you’ll still be able to opt-out\nwith <code>GOEXPERIMENT=nogreenteagc</code> at build time.\nGo 1.26 will also add vector acceleration on newer x86 hardware, and include a whole bunch of\ntweaks and improvements based on feedback we’ve collected so far.</p><p>If you can, we encourage you to try at Go tip-of-tree!\nIf you prefer to use Go 1.25, we’d still love your feedback.\nSee <a href=\"https://go.dev/issue/73581#issuecomment-2847696497\">this GitHub\ncomment</a> with some details on\nwhat diagnostics we’d be interested in seeing, if you can share, and the preferred channels for\nreporting feedback.</p><p>Before we wrap up this blog post, let’s take a moment to talk about the journey that got us here.\nThe human element of the technology.</p><p>The core of Green Tea may seem like a single, simple idea.\nLike the spark of inspiration that just one single person had.</p><p>But that’s not true at all.\nGreen Tea is the result of work and ideas from many people over several years.\nSeveral people on the Go team contributed to the ideas, including Michael Pratt, Cherry Mui, David\nChase, and Keith Randall.\nMicroarchitectural insights from Yves Vandriessche, who was at Intel at the time, also really helped\ndirect the design exploration.\nThere were a lot of ideas that didn’t work, and there were a lot of details that needed figuring out.\nJust to make this single, simple idea viable.</p><p>The seeds of this idea go all the way back to 2018.\nWhat’s funny is that everyone on the team thinks someone else thought of this initial idea.</p><p>Green Tea got its name in 2024 when Austin worked out a prototype of an earlier version while cafe\ncrawling in Japan and drinking LOTS of matcha!\nThis prototype showed that the core idea of Green Tea was viable.\nAnd from there we were off to the races.</p><p>Throughout 2025, as Michael implemented and productionized Green Tea, the ideas evolved and changed even\nfurther.</p><p>This took so much collaborative exploration because Green Tea is not just an algorithm, but an entire\ndesign space.\nOne that we don’t think any of us could’ve navigated alone.\nIt’s not enough to just have the idea, but you need to figure out the details and prove it.\nAnd now that we’ve done it, we can finally iterate.</p><p>The future of Green Tea is bright.</p><p>Once again, please try it out by setting  and let us know how it goes!\nWe’re really excited about this work and want to hear from you!</p>","contentLength":19499,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","go"]}