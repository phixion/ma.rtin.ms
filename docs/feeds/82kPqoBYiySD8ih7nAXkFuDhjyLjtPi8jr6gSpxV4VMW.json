{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"Go 1.26 is released","url":"https://go.dev/blog/go1.26","date":1770681600,"author":"Carlos Amedee, on behalf of the Go team","guid":84,"unread":true,"content":"<p>Today the Go team is pleased to release Go 1.26.\nYou can find its binary archives and installers on the <a href=\"https://go.dev/dl/\">download page</a>.</p><p>First, the built-in  function, which creates a new variable, now allows its operand to be an\nexpression, specifying the initial value of the variable.</p><p>A simple example of this change means that code such as this:</p><pre><code>x := int64(300)\nptr := &amp;x\n</code></pre><p>Second, generic types may now refer to themselves in their own type parameter list. This change\nsimplifies the implementation of complex data structures and interfaces.</p><p>The  command has been completely rewritten to use the\n<a href=\"https://go.dev/pkg/golang.org/x/tools/go/analysis\">Go analysis framework</a>, and now includes a\ncouple dozen ‚Äú<a href=\"https://go.dev/pkg/golang.org/x/tools/go/analysis/passes/modernize\">modernizers</a>‚Äù, analyzers\nthat suggest safe fixes to help your code take advantage of newer features of the language\nand standard library. It also includes the\n<a href=\"https://go.dev/pkg/golang.org/x/tools/go/analysis/passes/inline#hdr-Analyzer_inline\"> analyzer</a>, which\nattempts to inline all calls to each function annotated with a  directive.\nTwo upcoming blog posts will address these features in more detail.</p><h2>More improvements and changes</h2><p>Some of the additions in Go 1.26 are in an experimental stage\nand become exposed only when you explicitly opt in. Notably:</p><p>These experiments are all expected to be generally available in a\nfuture version of Go. We encourage you to try them out ahead of time.\nWe really value your feedback!</p><p>Please refer to the <a href=\"https://go.dev/doc/go1.26\">Go 1.26 Release Notes</a> for the complete list\nof additions, changes, and improvements in Go 1.26.</p><p>Over the next few weeks, follow-up blog posts will cover some of the topics\nrelevant to Go 1.26 in more detail. Check back later to read those posts.</p><p>Thanks to everyone who contributed to this release by writing code, filing bugs,\ntrying out experimental additions, sharing feedback, and testing the release candidates.\nYour efforts helped make Go 1.26 as stable as possible.\nAs always, if you notice any problems, please <a href=\"https://go.dev/issue/new\">file an issue</a>.</p><p>We hope you enjoy using the new release!</p>","contentLength":1861,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Results from the 2025 Go Developer Survey","url":"https://go.dev/blog/survey2025","date":1768953600,"author":"Todd Kulesza, on behalf of the Go team","guid":83,"unread":true,"content":"<p>Hello! In this article we‚Äôll discuss the results of the 2025 Go Developer\nSurvey, conducted during September 2025.</p><p>Thank you to the 5,379 Go developers who responded to our survey invitation\nthis year. Your feedback helps both the Go team at Google and the wider Go\ncommunity understand the current state of the Go ecosystem and prioritize\nprojects for the year ahead.</p><p>Our three biggest findings are:</p><ul><li>Broadly speaking, Go developers asked for help with identifying and applying\nbest practices, making the most of the standard library, and expanding the\nlanguage and built-in tooling with more modern capabilities.</li><li>Most Go developers are now using AI-powered development tools when seeking\ninformation (e.g., learning how to use a module) or toiling (e.g., writing\nrepetitive blocks of similar code), but their satisfaction with these tools\nis middling due, in part, to quality concerns.</li><li>A surprisingly high proportion of respondents said they frequently need to\nreview documentation for core  subcommands, including , , and , suggesting meaningful room for improvement with the \ncommand‚Äôs help system.</li></ul><p>Read on for the details about these findings, and much more.</p><p>Most survey respondents self-identified as professional developers (87%) who\nuse Go for their primary job (82%). A large majority also uses Go for personal\nor open-source projects (72%). Most respondents were between 25 ‚Äì 45\nyears old (68%) with at least six years of professional development experience\n(75%). Going deeper, 81% of respondents told us they had more professional\ndevelopment experience than Go-specific experience, strong evidence that Go is\nusually not the first language developers work with. In fact, one of the\nthemes that repeatedly surfaced during this year‚Äôs survey analysis seems to\nstem from this fact: when the way to do a task in Go is substantially\ndifferent from a more familiar language, it creates friction for developers to\nfirst learn the new (to them) idiomatic Go pattern, and then to consistently\nrecall these differences as they continue to work with multiple languages.\nWe‚Äôll return to this theme later.</p><p>The single most common industry respondents work in was ‚ÄúTechnology‚Äù (46%),\nbut a majority of respondents work outside of the tech industry (54%). We saw\nrepresentation of all sizes of organizations, with a bare majority working\nsomewhere with 2 ‚Äì 500 employees (51%), 9% working alone, and 30%\nworking at enterprises of over 1,000 employees. As in prior years, a majority\nof responses come from North America and Europe.</p><p>This year we observed a decrease in the proportion of respondents who said\nthey were fairly new to Go, having worked with it for less than one year\n(13%, vs. 21% in 2024). We suspect this is related to <a href=\"https://digitaleconomy.stanford.edu/wp-content/uploads/2025/08/Canaries_BrynjolfssonChandarChen.pdf\">industry-wide\ndeclines in entry-level software engineering roles</a>; we commonly hear from\npeople that they learned Go for a specific job, so a downturn in hiring would\nbe expected to reduce the number of developers learning Go in that year. This\nhypothesis is further supported by our finding that over 80% of respondents\nlearned Go  beginning their professional career.</p><p>Other than the above, we found no significant changes in other demographics\nsince our 2024 survey.</p><h2>How do people feel about Go?</h2><p>The vast majority of respondents (91%) said they felt satisfied while working\nwith Go. Almost ‚Öî were ‚Äúvery satisfied‚Äù, the highest rating. Both of these\nmetrics are incredibly positive, and have been stable since we began asking\nthis question in 2019. The stability over time is really what we monitor from\nthis metric ‚Äî we view it as a lagging indicator, meaning by the time\nthis satisfaction metric shows a meaningful change, we would expect to already\nhave seen earlier signals from issue reports, mailing lists, or other\ncommunity feedback.</p><p>Why were respondents so positive about Go? Looking at open-text responses to\nseveral different survey questions suggests that it‚Äôs the gestalt, rather than\nany one thing. These folks are telling us that they find tremendous value in\nGo as a holistic platform. That doesn‚Äôt mean it supports all programming\ndomains equally well (it surely does not), but that developers‚Äô value the\ndomains it  nicely support via stdlib and built-in tooling.</p><p>Below are some representative quotations from respondents. To provide context\nfor each quote, we also identify the satisfaction level, years of experience\nwith Go, and industry of the respondent.</p><blockquote><p>‚ÄúGo is by far my favorite language; other languages feel far too complex and\nunhelpful. The fact that Go is comparatively small, simple, with fewer bells\nand whistles plays a massive role in making it such a good long-lasting\nfoundation for building programs with it. I love that it scales well to\nbeing used by a single programmer and in large teams.‚Äù </p></blockquote><blockquote><p>‚ÄúThe entire reason I use Go is the great tooling and standard library.  I‚Äôm\nvery thankful to the team for focusing on great HTTP, crypto, math, sync,\nand other tools that make developing service-oriented applications easy and\nreliable.‚Äù </p></blockquote><blockquote><p>‚Äú[The] Go ecosystem is the reason why I really like the programming\nlanguage. There are a lot of npm issues lately but not with Go.‚Äù </p></blockquote><p>This year we also asked about the other languages that people use. Survey\nrespondents said that besides Go, they enjoy working with Python, Rust, and\nTypeScript, among a long tail of other languages. Some shared characteristics\nof these languages align with common points of friction reported by Go\ndevelopers, including  areas like error handling, enums, and object-oriented\ndesign patterns. For example, when we sum the proportion of respondents who\nsaid their next-favorite language included one of the following factors, we\nfound that majorities of respondents enjoy using languages with inheritance,\ntype-safe enums, and exceptions, with only a bare majority of these languages\nincluding a static type system by default.</p><table><thead><tr><th>Proportion of respondents</th></tr></thead><tbody></tbody></table><p>We think this is important because it reveals the larger environment in which\ndevelopers operate ‚Äî it suggests that people need to use different\ndesign patterns for fairly mundane tasks, depending on the language of the\ncodebase they‚Äôre currently working on. This leads to additional cognitive load\nand confusion, not only among developers new to Go (who must learn idiomatic\nGo design patterns), but also among the many developers who work in multiple\ncodebases or projects. One way to alleviate this additional load is\ncontext-specific guidance, such as a tutorial on ‚ÄúError handling in Go for\nJava developers‚Äù. There may even be opportunities to build some of this\nguidance into code analyzers, making it easier to surface directly in an IDE.</p><p>This year we asked the Go community to share their sentiment towards the Go\nproject itself. These results were quite different from the 91% satisfaction\nrate we discussed above, and point to areas the Go Team plans to invest our\nenergy during 2026. In particular, we want to encourage more contributors to\nget involved, and ensure the Go Team accurately understands the challenges Go\ndevelopers currently face. We hope this focus, in turn, will help to increase\ndeveloper trust in both the Go project and the Go Team leadership. As one\nrespondent explained the problem:</p><blockquote><p>‚ÄúNow that the founding first generation of Go Team members [are] not\ninvolved much anymore in the decision making, I am a bit worried about the\nfuture of Go in terms of quality of maintenance, and its balanced decisions\nso far wrt to changes in the language and std lib. More presence in form of\ntalks [by] the new core team members about the current state and future\nplans might be helpful to strengthen trust.‚Äù </p></blockquote><h2>What are people building with Go?</h2><p>We revised this list of ‚Äúwhat types of things do you build with Go?‚Äù from 2024\nwith the intent of more usefully teasing apart what people are building with\nGo, and avoid confusion around evolving terms like ‚Äúagents‚Äù. Respondent‚Äôs top\nuse cases remain CLIs and API services, with no meaningful change in either\nsince 2024. In fact, a majority of respondents (55%) said they build \nCLIs and API services with Go. Over ‚Öì of respondents specifically build cloud\ninfrastructure tooling (a new category), and 11% work with ML models, tools,\nor agents (an expanded category). Unfortunately embedded use cases were left\noff of the revised list, but we‚Äôll fix this for next year‚Äôs survey.</p><p>Most respondents said they are not currently building AI-powered features into\nthe Go software they work on (78%), with ‚Öî reporting that their software does\nnot use AI functionality at all (66%). This appears to be a decrease in\nproduction-related AI usage year-over-year; in 2024, 59% of respondents were\nnot involved in AI feature work, while 39% indicated some level of\ninvolvement. That marks a shift of 14 points away from building AI-powered\nsystems among survey respondents, and may reflect some natural pullback from\nthe early hype around AI-powered applications: it‚Äôs plausible that lots of\nfolks tried to see what they could do with this technology during its initial\nrollout, with some proportion deciding against further exploration (at least\nat this time).</p><p>Among respondents who are building AI- or LLM-powered functionality, the most\ncommon use case was to create summaries of existing content (45%). Overall,\nhowever, there was little difference between most uses, with between 28%\n‚Äì 33% of respondents adding AI functionality to support classification,\ngeneration, solution identification, chatbots, and software development.</p><h2>What are the biggest challenges facing Go developers?</h2><p>One of the most helpful types of feedback we receive from developers are\ndetails about the challenges people run into while working with Go. The Go\nTeam considers this information holistically and over long time horizons,\nbecause there is often tension between improving Go‚Äôs rougher edges and\nkeeping the language and tooling consistent for developers. Beyond technical\nfactors, every change also incurs some cost in terms of developer attention\nand cognitive disruption. Minimizing disruption may sound a bit dull or\nboring, but we view this as an important strength of Go. As Russ Cox wrote in\n2023, <a href=\"https://go.dev/blog/compat\">‚ÄúBoring is good‚Ä¶ Boring means being able to focus on your work, not\non what‚Äôs different about Go.‚Äù</a>.</p><p>In that spirit, this year‚Äôs top challenges are not radically different from\nlast year‚Äôs. The top three frustrations respondents reported were ‚ÄúEnsuring\nour Go code follows best practices / Go idioms‚Äù (33% of respondents), ‚ÄúA\nfeature I value from another language isn‚Äôt part of Go‚Äù (28%), and ‚ÄúFinding\ntrustworthy Go modules and packages‚Äù (26%). We examined open-text responses to\nbetter understand what people meant. Let‚Äôs take a minute to dig into each.</p><p>Respondents who were most frustrated by writing idiomatic Go were often\nlooking for more official guidance, as well as tooling support to help enforce\nthis guidance in their codebase. As in prior surveys, questions about how to\nstructure Go projects were also a common theme. For example:</p><blockquote><p>‚ÄúThe simplicity of go helps to read and understand code from other\ndevelopers, but there are still some aspects that can differ quite a lot\nbetween programmers. Especially if developers come from other languages,\ne.g. Java.‚Äù </p></blockquote><blockquote><p>‚ÄúMore opinionated way to write go code. Like how to structure a Go project\nfor services/cli tool.‚Äù </p></blockquote><blockquote><p>‚ÄúIt‚Äôs hard to figure out what are good idioms. Especially since the core\nteam doesn‚Äôt keep Effective Go up-to-date.‚Äù </p></blockquote><p>The second major category of frustrations were language features that\ndevelopers enjoyed working with in other ecosystems. These open-text comments\nlargely focused on error handling and reporting patterns, enums and sum types,\nnil pointer safety, and general expressivity / verbosity:</p><blockquote><p>‚ÄúStill not sure what is the best way to do error handling.‚Äù </p></blockquote><blockquote><p>‚ÄúRust‚Äôs enums are great, and lead to writing great type safe code.‚Äù </p></blockquote><blockquote><p>‚ÄúThere is nothing (in the compiler) that stops me from using a maybe nil\npointer, or using a value without checking the err first. That should be\n[baked into] the type system.‚Äù </p></blockquote><blockquote><p>‚ÄúI like [Go] but I didn‚Äôt expect it to have nil pointer exceptions :)‚Äù </p></blockquote><blockquote><p>‚ÄúI often find it hard to build abstractions and to provide clear intention\nto the future readers of my code.‚Äù </p></blockquote><p>The third major frustration was finding trustworthy Go modules. Respondents\noften described two aspects to this problem. One is that they considered many\n3rd-party modules to be of marginal quality, making it hard for really good\nmodules to stand out. The second is identifying which modules are commonly\nused and under which types of conditions (including recent trends over time).\nThese are both problems that could be addressed by showing what we‚Äôll vaguely\ncall ‚Äúquality signals‚Äù on pkg.go.dev. Respondents provided helpful\nexplanations of the signals they use to identify trustworthy modules,\nincluding project activity, code quality, recent adoption trends, or the\nspecific organizations that support or rely upon the module.</p><blockquote><p>‚ÄúBeing able to filter by criteria like stable version, number of users and\nlast update age at pkg.go.dev could make things a bit easier.‚Äù </p></blockquote><blockquote><p>‚ÄúMany pacakges are just clones/forks or one-off pojects with no\nhistory/maintenance. [sic]‚Äù </p></blockquote><blockquote><p>‚ÄúMaybe flagging trustworthy packages based on experience, maturity and\ncommunity feedback?‚Äù </p></blockquote><p>We agree that these are all areas where the developer experience with Go could\nbe improved. The challenge, as discussed earlier, is doing so in such a way\nthat doesn‚Äôt lead to breaking changes, increased confusion among Go\ndevelopers, or otherwise gets in the way of people trying to get their work\ndone with Go. Feedback from this survey is a major source of information we\nuse when discussing proposals, but if you‚Äôd like to get involved more directly\nor follow along with other contributors, visit the <a href=\"https://github.com/golang/go/issues?q=state%3Aopen%20label%3AProposal\" rel=\"noreferrer\" target=\"_blank\">Go proposals on\nGitHub</a>;\nplease be sure to <a href=\"https://github.com/golang/proposal\" rel=\"noreferrer\" target=\"_blank\">follow this process</a> if\nyou‚Äôd like to add a new proposal.</p><p>In addition to these (potentially) ecosystem-wide challenges, this year we\nalso asked specifically about working with the  command. We‚Äôve informally\nheard from developers that this tool‚Äôs help system can be confusing to\nnavigate, but we haven‚Äôt had a great sense of how frequently people find\nthemselves reviewing this documentation.</p><p>Respondents told us that except for , between 15% ‚Äì 25% of them\nfelt they ‚Äúoften needed to review documentation‚Äù with working with these\ntools. This was surprising, especially for commonly-used subcommands like\n and . Common reasons included remembering specific flags,\nunderstanding what different options do, and navigating the help system\nitself. Participants also confirmed that infrequent use was one reason for\nfrustration, but navigating and parsing command help appears to be the\nunderlying cause. In other words, we all expect to need to review\ndocumentation sometimes, but we don‚Äôt expect to need help navigating the\ndocumentation system itself. As on respondent described their journey:</p><blockquote><p>‚ÄúAccessing the help is painful. go test ‚Äìhelp # didn‚Äôt work, but tell[s] me\nto type  instead‚Ä¶ go help test # oh, actually, the info I‚Äôm\nlooking for is in  go help testflag # visually parsing through\ntext that looks all the same without much formatting‚Ä¶ I just lack time to\ndig into this rabbit hole.‚Äù </p></blockquote><h2>What does their development environment look like?</h2><h3>Operating systems and architectures</h3><p>Generally, respondents told us their development platforms are UNIX-like. Most\nrespondents develop on macOS (60%) or Linux (58%) and deploy to Linux-based\nsystems, including containers (96%). The largest year-over-year change was\namong ‚Äúembedded devices / IoT‚Äù deployments, which increased from 2% -&gt; 8% of\nrespondents; this was the only meaningful change in deployment platforms since\n2024.</p><p>The vast majority of respondents develop on x86-64 or ARM64 architectures,\nwith a sizable group (25%) still potentially working on 32-bit x86 systems.\nHowever, we believe the wording of this question was confusing to respondents;\nnext year we‚Äôll clarify the 32-bit vs. 64-bit distinction for each\narchitecture.</p><p>Several new code editors have become available in the past two years, and we\nexpanded our survey question to include the most popular ones. While we saw\nsome evidence of early adoption, most respondents continued to favor <a href=\"https://code.visualstudio.com/\" rel=\"noreferrer\" target=\"_blank\">VS\nCode</a> (37%) or\n<a href=\"https://www.jetbrains.com/go/\" rel=\"noreferrer\" target=\"_blank\">GoLand</a> (28%). Of the newer editors, Zed and\nCursor were the highest ranked, each becoming the preferred editor of 4% of\nrespondents. To put those numbers in context, we looked back at when VS Code\nand GoLand were first introduced. VS Code (released in 2015) was favored by\n16% of respondents one year after its release. IntelliJ has had a\ncommunity-led Go plugin longer than we‚Äôve been surveying Go developers (üíô),\nbut if we look at when JetBrains began officially supporting Go in IntelliJ\n(2016), within one year IntelliJ was preferred by 20% of respondents.</p><p>Note: This analysis of code editors does not include respondents who were\nreferred to the survey directly from VS Code or GoLand.</p><p>The most common deployment environments for Go continue to be Amazon Web\nServices (AWS) at 46% of respondents, company-owned servers (44%), and Google\nCloud Platform (GCP) at 26%. These numbers show minor shifts since 2024, but\nnothing statistically significant. We found that the ‚ÄúOther‚Äù category\nincreased to 11% this year, and this was primarily driven by Hetzner (20% of\nOther responses); we plan to include Hetzner as a response choice in next\nyear‚Äôs survey.</p><p>We also asked respondents about their development experience of working with\ndifferent cloud providers. The most common responses, however, showed that\nrespondents weren‚Äôt really sure (46%) or don‚Äôt directly interact with public\ncloud providers (21%). The biggest driver behind these responses was a theme\nwe‚Äôve heard often before: with containers, it‚Äôs possible to abstract many\ndetails of the cloud environment away from the developer, so that they don‚Äôt\nmeaningfully interact with most provider-specific technologies. This result\nsuggests that even developers whose work is  to clouds may have\nlimited experience with the larger suite of tools and technology associated\nwith each cloud provider. For example:</p><blockquote><p>‚ÄúKinda abstract to the platform, Go is very easy to put in a container and\nso pretty easy to deploy anywhere: one of its big strength[s].‚Äù </p></blockquote><blockquote><p>‚ÄúThe cloud provider really doesn‚Äôt make much difference to me. I write code\nand deploy it to containers, so whether that‚Äôs AWS or GCP I don‚Äôt really\ncare.‚Äù </p></blockquote><p>We suspect this level of abstraction is dependant on the use case and\nrequirements of the service that‚Äôs being deployed ‚Äî it may not always\nmake sense or be possible to keep it highly abstracted. In the future, we plan\nto further investigate how Go developers tend to interact with the platforms\nwhere their software is ultimately deployed.</p><p>Finally, we can‚Äôt discuss development environments in 2025 without also\nmentioning AI-powered software development tools. Our survey suggests\nbifurcated adoption ‚Äî while a majority of respondents (53%) said they\nuse such tools daily, there is also a large group (29%) who do not use these\nat all, or only used them a few times during the past month. We expected this\nto negatively correlate with age or development experience, but were unable to\nfind strong evidence supporting this theory except for  new developers:\nrespondents with less than one year of professional development experience\n(not specific to Go) did report more AI use than every other cohort, but this\ngroup only represented 2% of survey respondents.</p><p>At this time, agentic use of AI-powered tools appears nascent among Go\ndevelopers, with only 17% of respondents saying this is their primary way of\nusing such tools, though a larger group (40%) are occasionally trying agentic\nmodes of operation.</p><p>The most commonly used AI assistants remain ChatGPT, GitHub Copilot, and\nClaude. Most of these agents show lower usage numbers <a href=\"https://go.dev/blog/survey2024-h2-results#ai-assistance\">compared with our 2024\nsurvey</a> (Claude and Cursor are\nnotable exceptions), but due to a methodology change, this is not an\napples-to-apples comparison. It is, however, plausible that developers are\n‚Äúshopping around‚Äù less than they were when these tools were first released,\nresulting in more people using a single assistant for most of their work.</p><p>We also asked about overall satisfaction with AI-powered development tools. A\nmajority (55%) reported being satisfied, but this was heavily weighted towards\nthe ‚ÄúSomewhat satisfied‚Äù category (42%) vs. the ‚ÄúVery satisfied‚Äù group (13%).\nRecall that Go itself consistently shows a 90%+ satisfaction rate each year;\nthis year, 62% of respondents said they are ‚ÄúVery satisfied‚Äù with Go. We add\nthis context to show that while AI-powered tooling is starting to see adoption\nand finding some successful use cases, developer sentiment  towards them\nremains much softer than towards more established tooling (among Go\ndevelopers, at least).</p><p>What is driving this lower rate of satisfaction? In a word: quality. We asked\nrespondents to tell us something good they‚Äôve accomplished with these tools,\nas well as something that didn‚Äôt work out well. A majority said that creating\nnon-functional code was their primary problem with AI developer tools (53%),\nwith 30% lamenting that even working code was of poor quality. The most\nfrequently cited benefits, conversely, were generating unit tests, writing\nboilerplate code, enhanced autocompletion, refactoring, and documentation\ngeneration. These appear to be cases where code quality is perceived as less\ncritical, tipping the balance in favor of letting AI take the first pass at a\ntask. That said, respondents also told us the AI-generated code in these\nsuccessful cases still required careful review (and often, corrections), as it\ncan be buggy, insecure, or lack context.</p><blockquote><p>‚ÄúI‚Äôm never satisfied with code quality or consistency, it never follows the\npractices I want to.‚Äù </p></blockquote><blockquote><p>‚ÄúAll AI tools tend to hallucinate quickly when working with medium-to-large\ncodebases (10k+ lines of code). They can explain code effectively but\nstruggle to generate new, complex features‚Äù </p></blockquote><blockquote><p>‚ÄúDespite numerous efforts to make it write code in an established codebase,\nit would take too much effort to steer it to follow the practices in the\nproject, and it would add subtle behaviour paths - i.e. if it would miss\nsome method it would try to find its way around it or rely on some side\neffect. Sometimes those things are hard to recognize during code review. I\nalso found it mentally taxing to review ai generated code and that overhead\nkills the productivity potential in writing code.‚Äù </p></blockquote><p>When we asked developers what they used these tools for, a pattern emerged\nthat is consistent with these quality concerns. The tasks with most adoption\n(green in the chart below) and least resistance (red) deal with bridging\nknowledge gaps, improving local code, and avoiding toil. The frustrations that\ndevelopers talk about with code-generating tools were much less evident when\nthey‚Äôre seeking information, like how to use a specific API or configure test\ncoverage, and perhaps as a result, we see higher usage of AI in these areas.\nAnother spot that stood out was  code review and related suggestions\n‚Äî people were less interested in using AI to review other people‚Äôs code\nthan in reviewing their own. Surprisingly, ‚Äútesting code‚Äù showed lower AI\nadoption than other toilsome tasks, though we don‚Äôt yet have strong\nunderstanding of why.</p><p>Of all the tasks we asked about, ‚ÄúWriting code‚Äù was the most bifurcated, with\n66% of respondents already or hoping to soon use AI for this, while ¬º of\nrespondents didn‚Äôt want AI involved at all. Open-ended responses suggest\ndevelopers primarily use this for toilsome, repetitive code, and continue to\nhave concerns about the quality of AI-generated code.</p><p>Once again, a tremendous thank-you to everyone who responded to this year‚Äôs Go\nDeveloper Survey!</p><p>We plan to share the raw survey dataset in Q1 2026, so the larger community\ncan also explore the data underlying these findings. This will only include\nresponses from people who opted in to share this data (82% of all\nrespondents), so there may be some differences from the numbers we reference\nin this post.</p><p>This survey was conducted between Sept 9 - Sept 30, 2025. Participants were\npublicly invited to respond via the Go Blog, invitations on social media\nchannels (including Bluesky, Mastodon, Reddit, and X), as well as randomized\nin-product invitations to people using VS Code and GoLand to write Go\nsoftware. We received a total of 7,070 responses. After data cleaning to\nremove bots and other very low quality responses, 5,379 were used for the\nremainder of our analysis. The median survey response time was between 12\n‚Äì 13 minutes.</p><p>Throughout this report we use charts of survey responses to provide supporting\nevidence for our findings. All of these charts use a similar format. The title\nis the exact question that survey respondents saw. Unless otherwise noted,\nquestions were multiple choice and participants could only select a single\nresponse choice; each chart‚Äôs subtitle will tell the reader if the question\nallowed multiple response choices or was an open-ended text box instead of a\nmultiple choice question. For charts of open-ended text responses, a Go team\nmember read and manually categorized all of the responses. Many open-ended\nquestions elicited a wide variety of responses; to keep the chart sizes\nreasonable, we condensed them to a maximum of the top 10-12 themes, with\nadditional themes all grouped under ‚ÄúOther‚Äù. The percentage labels shown in\ncharts are rounded to the nearest integer (e.g., 1.4% and 0.8% will both be\ndisplayed as 1%), but the length of each bar and row ordering are based on the\nunrounded values.</p><p>To help readers understand the weight of evidence underlying each finding, we\nincluded error bars showing the 95% <a href=\"https://en.wikipedia.org/wiki/Confidence_interval\" rel=\"noreferrer\" target=\"_blank\">confidence\ninterval</a> for responses;\nnarrower bars indicate increased confidence. Sometimes two or more responses\nhave overlapping error bars, which means the relative order of those responses\nis not statistically meaningful (i.e., the responses are effectively tied).\nThe lower right of each chart shows the number of people whose responses are\nincluded in the chart, in the form ‚Äún = [number of respondents]‚Äù.</p>","contentLength":26365,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","go"]}